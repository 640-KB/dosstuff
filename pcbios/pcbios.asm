;TITLE(BIOS FOR IBM PERSONAL COMPUTER)

;----------------------------------------------------------------
;	THE  BIOS ROUTINES ARE MEANT TO BE ACCESSED THROUGH	:
;	SOFTWARE INTERRUPTS ONLY.  ANY ADDRESSES PRESENT IN	:
;	THE LISTINGS  ARE INCLUDED  ONLY FOR  COMPLETENESS,	:
;	NOT FOR  REFERENCE.   APPLICATIONS WHICH  REFERENCE	:
;	ABSOLUTE   ADDRESSES   WITHIN	THE  CODE   SEGMENT	:
;	VIOLATE THE STRUCTURE AND DESIGN OF BIOS.		:
;----------------------------------------------------------------

	%include "equs.inc"


;--------------------------------------------------------
;	STACK -- USED DURING INITIALIZATION ONLY	:
;--------------------------------------------------------
STACK		EQU 30H
TOS		EQU 256

	%include "biosdata.inc"

;----------------------------------------
;	   EXTRA DATA AREA		:
;----------------------------------------
XXDATA		EQU 50H
STATUS_BYTE	EQU 0

;----------------------------------------
;	VIDEO DISPLAY BUFFER		:
;----------------------------------------
VIDEO_RAM	EQU 0B800H
REGEN		EQU 0
REGENW		EQU 0
;----------------------------------------
;	  ROM RESIDENT CODE		:
;----------------------------------------
	SECTION	.text
	DB	57344 DUP(0)			; FILL LOWEST 56K

	DB	'1501476 COPR. IBM 1982'        ; COPYRIGHT NOTICE

;----------------------------------------------------------------
;	INITIAL RELIABILITY TESTS -- PHASE 1			:
;----------------------------------------------------------------
;----------------------------------------
;	DATA DEFINITIONS		:
;----------------------------------------
C1:
	DW	C11		; RETURN ADDRESS

;------------------------------------------------------------------------
;	THIS SUBROUTINE PERFORMS A READ/WRITE STORAGE TEST ON		:
;	A 16K BLOCK OF STORAGE. 					:
; ENTRY REQUIREMENTS:							:
;	ES = ADDRESS OF STORAGE SEGMENT BEING TESTED			:
;	DS = ADDRESS OF STORAGE SEGMENT BEING TESTED			:
;	WHEN ENTERING AT STGTST_CNT, CX MUST BE LOADED WITH		:
;	THE BYTE COUNT. 						:
; EXIT PARAMETERS:							:
;	ZERO FLAG = 0 IF STORAGE ERROR (DATA COMPARE OR PARITY CHECK.	:
;	       AL = 0 DENOTES A PARITY CHECK. ELSE AL=XOR'ED BIT        :
;		      PATTERN OF THE EXPECTED DATA PATTERN VS THE	:
;		      ACTUAL DATA READ. 				:
;	AX,BX,CX,DX,DI, AND SI ARE ALL DESTROYED.			:
;------------------------------------------------------------------------

STGTST:
	MOV	CX,04000H		; SETUP CNT TO TEST A 16K BLK
STGTST_CNT:
	CLD				; SET DIR FLAG TO INCREMENT
	MOV	BX,CX			; SAVE BYTE CNT (4K FOR VIDEO OR 16K)
	MOV	AX,0AAAAH		; GET DATA PATTERN TO WRITE
	MOV	DX,0FF55H		; SETUP OTHER DATA PATTERNS TO USE
	SUB	DI,DI			; DI = OFFSET 0 RELATIVE TO ES REG
	REP	STOSB			; WRITE STORAGE LOCATIONS
C3:					;  STG01
	DEC	DI			; POINT TO LAST BYTE JUST WRITTEN
	STD				; SET DIR FLAG TO GO BACKWARDS
C4:
	MOV	SI,DI
	MOV	CX,BX			; SETUP BYTE CNT
C5:					; INNER TEST LOOP
	LODSB				; READ OLD TST BYTE FROM STORAGE [SI]+
	XOR	AL,AH			; DATA READ AS EXPECTED ?
	JNE	C7			;  NO - GO TO ERROR ROUTINE
	MOV	AL,DL			; GET NEXT DATA PATTERN TO WRITE
	STOSB				; WRITE INTO LOCATION JUST READ [DI]+
	LOOP	C5			;  DECREMENT BYTE COUNT AND LOOP CX

	AND	AH,AH			; ENDING ZERO PATTERN WRITTEN TO STG ?
	JZ	C6X			; YES - RETURN TO CALLER WITH AL=0
	MOV	AH,AL			; SETUP NEW VALUE FOR COMPARE
	XCHG	DH,DL			; MOVE NEXT DATA PATTERN TO DL
	AND	AH,AH			; READING ZERO PATTERN THIS PASS ?
	JNZ	C6			; CONTINUE TEST SEQUENCE TILL ZERO DATA
	MOV	DL,AH			;  ELSE SET ZERO FOR END READ PATTERN
	JMP	SHORT C3		;  AND MAKE FINAL BACKWARDS PASS
C6:
	CLD				; SET DIR FLAG TO GO FORWARD
	INC	DI			; SET POINTER TO BEG LOCATION
	JZ	C4			; READ/WRITE FORWARD IN STG
	DEC	DI			; ADJUST POINTER
	MOV	DX,00001H		; SETUP 01 FOR PARITY BIT
					;  AND 00 FOR END
	JMP	SHORT C3		; READ/WRITE BACKWARD IN STG
C6X:
	IN	AL,PORT_C		; DID A PARITY ERROR OCCUR ?
	AND	AL,0C0H 		; ZERO FLAG WILL BE OFF PARITY ERROR
	MOV	AL,000H 		; AL=0 DATA COMPARE OK
C7:
	CLD				; SET DEFAULT DIRCTN FLAG BACK TO INC
	RET
;----------------------------------------------------------------
;	8088 PROCESSOR TEST					:
; DESCRIPTION							:
;	VERIFY 8088 FLAGS, REGISTERS AND CONDITIONAL JUMPS	:
;----------------------------------------------------------------
	TIMES	0E05BH-($-$$) DB 0FFh
RESET:
START:
	CLI				; DISABLE INTERRUPTS
	MOV	AH,0D5H 		; SET SF, CF, ZF, AND AF FLAGS ON
	SAHF
	JNC	ERR01			; GO TO ERR ROUTINE IF CF NOT SET
	JNZ	ERR01			; GO TO ERR ROUTINE IF ZF NOT SET
	JNP	ERR01			; GO TO ERR ROUTINE IF PF NOT SET
	JNS	ERR01			; GO TO ERR ROUTINE IF SF NOT SET
	LAHF				; LOAD FLAG IMAGE TO AH
	MOV	CL,5			; LOAD CNT REG WITH SHIFT CNT
	SHR	AH,CL			; SHIFT AF INTO CARRY BIT POS
	JNC	ERR01			; SO TO ERR ROUTINE IF AF NOT SET
	MOV	AL,40H			; SET THE OF FLAG ON
	SHL	AL,1			; SETUP FOR TESTING
	JNO	ERR01			; GO TO ERR ROUTINE IF OF NOT SET
	XOR	AH,AH			; SET AH = 0
	SAHF				; CLEAR SF, CF, ZF, AND PF
	JBE	ERR01			; GO TO ERR ROUTINE IF CF ON
					; OR TO TO ERR ROUTINE IF ZF ON
	JS	ERR01			; GO TO ERR ROUTINE IF SF ON
	JP	ERR01			; GO TO ERR ROUTINE IF PF ON
	LAHF				; LOAD FLAG IMAGE TO AH
	MOV	CL,5			; LOAD CNT REG WITH SHIFT CNT
	SHR	AH,CL			; SHIFT AH INTO CARRY BIT POS
	JC	ERR01			; GO TO ERR ROUTINE IF ON
	SHL	AH,1			; CHECK THAT OF IS CLEAR
	JO	ERR01			; GO TO ERR ROUTINE IF ON

;----- READ/WRITE THE 8088 GENERAL AND SEGMENTATION REGISTERS
;      WITH ALL ONE'S AND ZEROES'S.

	MOV	AX,0FFFFH		; SETUP ONE'S PATTERN IN AX
	STC
C8:
	MOV	DS,AX			; WRITE PATTERN TO ALL REGS
	MOV	BX,DS
	MOV	ES,BX
	MOV	CX,ES
	MOV	SS,CX
	MOV	DX,SS
	MOV	SP,DX
	MOV	BP,SP
	MOV	SI,BP
	MOV	DI,SI
	JNC	C9			; TST1A
	XOR	AX,DI			; PATTERN MAKE IT THRU ALL REGS
	JNZ	ERR01			; NO - GO TO ERR ROUTINE
	CLC
	JMP	SHORT C8
C9:					; TST1A
	OR	AX,DI			; ZERO PATTERN MAKE IT THRU?
	JZ	C10			; YES - GO TO NEXT TEST
ERR01:	HLT				; HALT SYSTEM
;--------------------------------------------------------
;	ROS CHECKSUM TEST I				:
;DESCRIPTION						:
;	A CHECKSUM IS DONE FOR THE 8K ROS MODULE	:
;	CONTAINING POD AND BIOS.			:
;--------------------------------------------------------
C10:
					; ZERO IN AL ALREADY
	OUT	0A0H,AL 		; DISABLE NMI INTERRUPTS
	OUT	83H,AL			; INITIALIZE DMA PAGE REG
	MOV	DX,3D8H
	OUT	DX,AL			; DISABLE COLOR VIDEO
	INC	AL
	MOV	DL,0B8H
	OUT	DX,AL			; DISABLE B/W VIDEO,EN HIGH RES
	MOV	AL,99H			; SET 8255 A,C-INPUT,B-OUTPUT
	OUT	CMD_PORT,AL		; WRITE 8255 CMD/MODE REG
	MOV	AL,0FCH 		; DISABLE PARITY CHECKERS AND
	OUT	PORT_B,AL		;  GATE SNS SWS,CASS MOTOR OFF
	MOV	AX,CS			; SETUP SS SEG REG
	MOV	SS,AX
	MOV	DS,AX			; SET UP DATA SEG TO POINT TO
					;  ROM ADDRESS
	MOV	BH,0E0H 		; SETUP STARTING ROS ADDR (E0000)
	MOV	SP,C1			; SETUP RETURN ADDRESS
	JMP	ROS_CHECKSUM
C11:
	JNE	ERR01			; HALT SYSTEM IF ERROR
;----------------------------------------------------------------
;	8237 DMA INITIALIZATION CHANNEL REGISTER TEST		:
;DESCRIPTION							:
;	DISABLE THE 8237 DMA CONTROLLER.  VERIFY THAT TIMER 1	:
;	FUNCTIONS OK. WRITE/READ THE CURRENT ADDRESS AND WORD	:
;	COUNT REGISTERS FOR ALL CHANNELS.  INITIALIZE AND	:
;	START DMA FOR MEMORY REFRESH.				:
;----------------------------------------------------------------
	MOV	AL,04			; DISABLE DMA CONTROLLER
	OUT	DMA08,AL

;----- VERIFY THAT TIMER 1 FUNCTIONS OK

	MOV	AL,54H			; SEL TIMER 1,LSB,MODE 2
	OUT	TIMER+3,AL
	MOV	AL,CL			; SET INITIAL TIMER CNT TO 0
	OUT	TIMER+1,AL
C12:					; TIMER1_BITS_ON
	MOV	AL,40H			; LATCH TIMER 1 COUNT
	OUT	TIMER+3,AL
	CMP	BL,0FFH 		; YES - SEE IF ALL BITS GO OFF
	JE	C13			; TIMER1_BITS_OFF
	IN	AL,TIMER+1		; READ TIMER 1 COUNT
	OR	BL,AL			; ALL BITS ON IN TIMER
	LOOP	C12			; TIMER1_BITS_ON
	HLT				; TIMER 1 FAILURE, HALT SYS
C13:					; TIMER1_BITS_OFF
	MOV	AL,BL			; SET TIMER 1 CNT
	SUB	CX,CX
	OUT	TIMER+1,AL
C14:					; TIMER_LOOP
	MOV	AL,40H			; LATCH TIMER 1 COUNT
	OUT	TIMER+3,AL
	NOP				; DELAY FOR TIMER
	NOP
	IN	AL,TIMER+1		; READ TIMER 1 COUNT
	AND	BL,AL
	JZ	C15			; GO TO WRAP_DMA_REG
	LOOP	C14			; TIMER_LOOP
	HLT				; TIMER ERROR - HALT SYSTEM

;----- INITIALIZE TIMER 1 TO REFRESH MEMORY

C15:					; WRAP_DMA_REG
	MOV	AL,18			; SETUP DIVISOR FOR REFRESH
	OUT	TIMER+1,AL		; WRITE TIMER 1 CNT REG
	OUT	DMA+0DH,AL		; SEND MASTER CLEAR TO DMA

;----- WRAP DMA CHANNELS ADDRESS AND COUNT REGISTERS

	MOV	AL,0FFH 		; WRITE PATTERN FF TO ALL REGS
C16:
	MOV	BL,AL			; SAVE PATTERN FOR COMPARE
	MOV	BH,AL
	MOV	CX,8			; SETUP LOOP CNT
	SUB	DX,DX			; SETUP I/O PORT ADDR OF REG (0000)
C17:
	OUT	DX,AL			; WRITE PATTERN TO REG, LSB
	PUSH	AX
	OUT	DX,AL			; MSB OF 16 BIT REG
	MOV	AX,0101H		; AX TO ANOTHER PAT BEFORE RD
	IN	AL,DX			; READ 16-BIT DMA CH REG, LSB
	MOV	AH,AL			; SAVE LSB OF 16-BIT REG
	IN	AL,DX			; READ MSB OF DMA CH REG
	CMP	BX,AX			; PATTERN READ AS WRITTEN?
	JE	C18			; YES - CHECK NEXT REG
	HLT				; NO - HALT THE SYSTEM
C18:					; NXT_DMA_CH
	INC	DX			; SET I/O PORT TO NEXT CH REG
	LOOP	C17			; WRITE PATTERN TO NEXT REG
	INC	AL			; SET PATTERN TO 0
	JZ	C16			; WRITE TO CHANNEL REGS

;----- INITIALIZE AND START DMA FOR MEMORY REFRESH.

	MOV	DS,BX			; SET UP ABS0 INTO DS AND ES
	MOV	ES,BX

	MOV	AL,0FFH 		; SET CNT OF 64K FOR RAM REFRESH
	OUT	DMA+1,AL
	PUSH	AX
	OUT	DMA+1,AL
	MOV	DL,0BH			; DX=000B
	MOV	AL,058H 		; SET DMA MODE,CH 0,READ,AUTOINT
	OUT	DX,AL			; WRITE DMA MODE REG
	MOV	AL,0			; ENABLE DMA CONTROLLER
	OUT	DMA+8,AL		; SETUP DMA COMMAND REG
	PUSH	AX
	OUT	DMA+10,AL		; ENABLE CHANNEL 0 FOR REFRESH
	MOV	CL,3
	MOV	AL,41H			; SET MODE FOR CHANNEL 1
C18A:
	OUT	DX,AL
	INC	AL			; POINT TO NEXT CHANNEL
	LOOP	C18A
;----------------------------------------------------------------
;	BASE 16K READ/WRITE STORAGE TEST			:
;DESCRIPTION							:
;	WRITE/READ/VERIFY DATA PATTERNS FF,55,AA,01, AND 00	:
;	TO 1ST 16K OF STORAGE.	VERIFY STORAGE ADDRESSABILITY.	:
;	INITIALIZE THE 8259 INTERRUPT CONTROLLER CHIP FOR	:
;	CHECKING MANUFACTURING TEST 2 MODE.			:
;----------------------------------------------------------------

;----- DETERMINE MEMORY SIZE AND FILL MEMORY WITH DATA

	MOV	DX,0213H		; ENABLE EXPANSION BOX
	MOV	AL,01H
	OUT	DX,AL
	MOV	BP,[DATA_WORD+BiosData.resetFlag] ; SAVE 'RESET_FLAG' IN BP
	CMP	BP,1234H		; WARM START?
	JE	C18B			; BYPASS STG TST.
	MOV	SP,C2
	NOP
	JMP	STGTST
C24:
	JE	C18B			; PROCEED IF STGTST OK
	HLT				; HALT IF NOT
C18B:
	SUB	DI,DI
	IN	AL,PORT_A		; DETERMINE BASE RAM SIZE
	AND	AL,0CH			; ISOLATE RAM SIZE SWS
	ADD	AL, 4			; CALCULATE MEMORY SIZE
	MOV	CL, 12
	SHL	AX, CL
	MOV	CX, AX
	CLD				; SET DIR FLAG TO INCR
C19:
	STOSB				; FILL BASE RAM WITH DATA
	LOOP	C19			; LOOP TIL ALL ZERO
	MOV	[DATA_WORD+BiosData.resetFlag],BP

;----- DETERMINE IO CHANNEL RAM SIZE

	MOV	AL,0F8H 		; ENABLE SWITCH 5
	OUT	PORT_B,AL
	IN	AL,PORT_C		; READ SWITCHES
	AND	AL,00000001B		; ISOLATE SWITCH 5
	MOV	CL,12D
	ROL	AX,CL
	MOV	AL,0FCH 		; DISABLE SW. 5
	OUT	PORT_B,AL
	IN	AL,PORT_C
	AND	AL,0FH
	OR	AL,AH			; COMBINE SWITCH VALUES
	MOV	BL,AL			; SAVE
	MOV	AH,32
	MUL	AH			; CALC. LENGTH
	MOV	[DATA_WORD+BiosData.ioRamSize],AX	;SAVE IT
	JZ	C21
	MOV	DX,1000H		; SEGMENT FOR I/O RAM
	MOV	AH,AL
	MOV	AL,0
C20:					; FILL_IO:
	MOV	ES,DX
	MOV	CX,8000H		; FILL 32K BYTES
	SUB	DI,DI
	REP	STOSB
	ADD	DX,800H 		; NEXT SEGMENT VALUE
	DEC	BL
	JNZ	C20			; FILL_IO
;----------------------------------------------------------------
;	INITIALIZE THE 8259 INTERRUPT CONTROLLER CHIP		:
;----------------------------------------------------------------
C21:
	MOV	AL,13H			; ICW1 - EDGE, SNGL, ICW4
	OUT	INTA00,AL
	MOV	AL,8			; SETUP ICW2 - INT TYPE 8 (8-F)
	OUT	INTA01,AL
	MOV	AL,9			; SETUP ICW4 - BUFFRD,8086 MODE
	OUT	INTA01,AL
	SUB	AX,AX			; POINT ES TO BEGIN
	MOV	ES,AX			;  OF R/W STORAGE
;---------------------------------------------------------------------------
;	CHECK FOR MANUFACTURING TEST 2 TO LOAD TEST PROGRAMS FROM KEYBOARD.:
;---------------------------------------------------------------------------

;----- SETUP STACK SEG AND SP

	MOV	AX,STACK		; GET STACK VALUE
	MOV	SS,AX			; SET THE STACK UP
	MOV	SP,TOS			; STACK IS READY TO GO
	CMP	BP,1234H		; RESET_FLAG SET?
	JE	C25			; YES - SKIP MFG TEST
	SUB	DI,DI
	MOV	DS, DI
	MOV	BX, 24H
	MOV	WORD [BX],D11		; SET UP KB INTERRUPT
	INC	BX
	INC	BX
	MOV	[BX],CS
	CALL	KBD_RESET		; READ IN KB RESET CODE TO BL
	CMP	BL,065H 		; IS THIS MANUFACTURING TEST 2?
	JNZ	C25			; JUMP IF NOT MAN. TEST
	MOV	DL,255			; READ IN TEST PROGRAM
C22:
	CALL	SP_TEST
	MOV	AL,BL
	STOSB
	DEC	DL
	JNZ	C22			; JUMP IF NOT DONE RET
	INT	3EH			; SET INTERUPT TYPE 62 ADDRESS F8H
C25:

;----- SET UP THE BIOS INTERRUPT VECTORS TO TEMP INTERRUPT

	MOV	CX,32			; FILL ALL 32 INTERRUPTS
	SUB	DI,DI			; FIRST INTERRUPT LOCATION
D3:
	MOV	AX,D11			; MOVE ADDR OF INTR PROC TO TBL
	STOSW
	MOV	AX,CS			; GET ADDR OF INTR PROC SEG
	STOSW
	LOOP	D3			; VECTBL0

;----- SET UP OTHER INTERRUPTS AS NECESSARY

	MOV	WORD [NMI_PTR],NMI_INT	; NMI INTERRUPT
	MOV	WORD [INT5_PTR],PRINT_SCREEN	; PRINT SCREEN
	MOV	WORD [BASIC_PTR+2],0F600H	; SEGMENT FOR CASSETTE BASIC

;----------------------------------------------------------------
;	8259 INTERRUPT CONTROLLER TEST				:
;DESCRIPTION							:
;	READ/WRITE THE INTERRUPT MASK REGISTER (IMR) WITH ALL	:
;	ONES AND ZEROES. ENABLE SYSTEM INTERRUPTS.  MASK DEVICE :
;	INTERRUPTS OFF. CHECK FOR HOT INTERRUPTS (UNEXPECTED).	:
;----------------------------------------------------------------

;----- TEST THE IMR REGISTER

	MOV	DX,0021H		; POINT INTR. CHIP ADDR 21
	MOV	AL,0			; SET IMR TO ZERO
	OUT	DX,AL
	IN	AL,DX			; READ IMR
	OR	AL,AL			; IMR = 0?
	JNZ	D6			; GO TO ERR ROUTINE IF NOT 0
	MOV	AL,0FFH 		; DISABLE DEVICE INTERRUPTS
	OUT	DX,AL			; WRITE TO IMR
	IN	AL,DX			; READ IMR
	ADD	AL,1			; ALL IMR BITS ON?
	JNZ	D6			; NO - GO TO ERR ROUTINE

;----- CHECK FOR HOT INTERRUPTS

;----- INTERRUPTS ARE MASKED OFF.  CHECK THAT NO INTERRUPTS OCCUR

	XOR	AH,AH			; CLEAR AH REG
	STI				; ENABLE EXTERNAL INTERRUPTS
	SUB	CX,CX			; WAIT 1 SEC FOR ANY INTRS THAT
D4:
	LOOP	D4			;  MIGHT OCCUR
D5:
	LOOP	D5
	OR	AH,AH			; DID ANY INTERRUPTS OCCUR?
	JZ	D7			; NO - GO TO NEXT TEST
D6:
	MOV	DX,101H 		; BEEP SPEAKER IF ERROR
	CALL	ERR_BEEP		; GO TO BEEP SUBROUTINE
	CLI
	HLT				; HALT THE SYSTEM
;------------------------------------------------
;	8253 TIMER CHECKOUT			:
;DESCRIPTION					:
;	VERIFY THAT THE SYSTEM TIMER (0)	:
;	DOESN'T COUNT TOO FAST OR TOO SLOW.     :
;------------------------------------------------
D7:
	MOV	AL,0FEH 		; MASK ALL INTRS EXCEPT LVL 0
	OUT	DX,AL			; WRITE THE 8259 IMR
	MOV	AL,00010000B		; SEL TIM 0, LSB, MODE 0, BINARY
	OUT	TIM_CTL,AL		; WRITE TIMER CONTROL MODE REG
	MOV	CX,16H			; SET PGM LOOP CNT
	MOV	AL,CL			; SET TIMER 0 CNT REG
	OUT	TIMER0,AL		; WRITE TIMER 0 CNT REG
D8:
	TEST	AH,0FFH 		; DID TIMER 0 INTERRUPT OCCUR?
	JNZ	D9			; YES - CHECK TIMER OP FOR SLOW TIME
	LOOP	D8			; WAIT FOR INTR FOR SPECIFIED TIME
	JMP	SHORT D6		; TIMER 0 INTR DIDN'T OCCUR - ERR
D9:
	MOV	CL,18			; SET PGM LOOP CNT
	MOV	AL,0FFH 		; WRITE TIMER 0 CNT REG
	OUT	TIMER0,AL
	MOV	AX,0FEH
	OUT	DX,AL
D10:
	TEST	AH,0FFH 		; DID TIMER 0 INTERRUPT OCCUR?
	JNZ	D6			; YES - TIMER CNTING TOO FAST, ERR
	LOOP	D10			; WAIT FOR INTR FOR SPECIFIED TIME

;----- ESTABLISH BIOS SUBROUTINE CALL INTERRUPT VECTORS

	PUSH	DS			; SAVE POINTER TO DATA AREA
	MOV	DI,VIDEO_INT		; SETUP ADDR TO INTR AREA
	PUSH	CS
	POP	DS			; SETUP ADDR OF VECTOR TABLE
	MOV	SI,VECTOR_TABLE+16	; START WITH VIDEO ENTRY
	NOP
	MOV	CX,16

;----- SETUP TIMER 0 TO MODE 3

	MOV	AL,0FFH 		; DISABLE ALL DEVICE INTERRUPTS
	OUT	DX,AL
	MOV	AL,36H			; SEL TIM 0,LSB,MSB,MODE 3
	OUT	TIMER+3,AL		; WRITE TIMER MODE PEG
	MOV	AL,0
	OUT	TIMER,AL		; WRITE LSB TO TIMER 0 REG
E1A:
	MOVSW				; MOVE VECTOR TABLE TO RAM
	INC	DI			; MOVE PAST SEGMENT POINTER
	INC	DI
	LOOP	E1A
	OUT	TIMER,AL		; WRITE MSB TO TIMER 0 REG
	POP	DS			; RECOVER DATA SEG POINTER

;----- SETUP TIMER 0 TO BLINK LED IF MANUFACTURING TEST MODE

	CALL	KBD_RESET		; SEND SOFTWARE RESET TO KEYBRD
	CMP	BL,0AAH 		; SCAN CODE 'AA' RETURNED?
	JE	E6			; YES - CONTINUE (NON MFG MODE)
	MOV	AL,3CH			; EN KBD, SET KBD CLK LINE LOW
	OUT	PORT_B,AL		; WRITE 8255 PORT B
	NOP
	NOP
	IN	AL,PORT_A		; WAS A BIT CLOCKED IN?
	AND	AL,0FFH
	JNZ	E2			; YES - CONTINUE (NON MFG MODE)
	INC	BYTE [DATA_AREA+BiosData.mfgTest]	; ELSE SET SW FOR MFG TEST MODE
	MOV	WORD [INT_ADDR],BLINK_INT	; SETUP TIMER INTR TO BLINK LED
	MOV	AL,0FEH 		; ENABLE TIMER INTERRUPT
	OUT	INTA01,AL
E2:					; JUMPER_NOT_IN:
	MOV	AL,0CCH 		; RESET THE KEYBOARD
	OUT	PORT_B,AL

;--------------------------------------------------------
;	INITIALIZE AND START CRT CONTROLLER (6845)	:
;	TEST VIDEO READ/WRITE STORAGE.			:
;DESCRIPTION						:
;	RESET THE VIDEO ENABLE SIGNAL.			:
;	SELECT ALPHANUMERIC MODE, 40 * 25, B & W.	:
;	READ/WRITE DATA PATTERNS TO STG. CHECK STG	:
;	ADDRESSABILITY. 				:
;--------------------------------------------------------
E6:
	IN	AL,PORT_A		; READ SENSE SWITCHES
	MOV	AH,0
	MOV	[DATA_WORD+BiosData.equipFlag],AX ; STORE SENSE SW INFO
E6A:
	AND	AL,30H			; ISOLATE VIDEO SW
	JNZ	E7			; VIDEO SWS SET TO 0?
	MOV	WORD [VIDEO_INT],DUMMY_RETURN
	JMP	E18_1			; SKIP VIDEO TESTS FOR BURN-IN

	TIMES	0E2C3H-($-$$) DB 0FFh
NMI_INT:
	PUSH	AX			; SAVE ORIG CONTENTS OF AX
	IN	AL,PORT_C
	TEST	AL,0C0H 		; PARITY CHECK?
	JZ	D14			; NO, EXIT FROM ROUTINE
	MOV	SI,D1			; ADDR OF ERROR MSG
	NOP
	TEST	AL,40H			; I/O PARITY CHECK?
	JNZ	D13			; DISPLAY ERROR MSG
	MOV	SI,D2			; MUST BE PLANAR
	NOP
D13:
	SUB	AX,AX			; INIT AND SET MODE FOR VIDEO
	INT	10H			; CALL VIDEO_IO PROCEDURE
	CALL	P_MSG			; PRINT ERROR MSG
	CLI
	HLT				; HALT SYSTEM
D14:
	POP	AX			; RESTORE ORIG CONTENTS OF AX
	IRET

E7:					; TEST_VIDEO:
	CMP	AL,30H			; B/W CARD ATTACHED?
	JE	E8			; YES - SET MODE FOR B/W CARD
	INC	AH			; SET COLOR MODE FOR COLOR CD
	CMP	AL,20H			; 80X25 MODE SELECTED?
	JNE	E8			; NO - SET MODE FOR 40X25
	MOV	AH,3			; SET MODE FOR 80X25
E8:
	XCHG	AH,AL			; SET_MODE
	PUSH	AX			; SAVE VIDEO MODE ON STACK
	SUB	AH,AH			; INITIALIZE TO ALPHANUMERIC MD
	INT	10H			; CALL VIDEO_IO
	POP	AX			; RESTORE VIDEO SENSE SWS IN AH
	PUSH	AX			; RESAVE VALUE
	MOV	BX,0B000H		; BEG VIDEO RAM ADDR B/W CD
	MOV	DX,3B8H 		; MODE REG FOR B/W
	MOV	CX,4096 		; RAM BYTE CNT FOR B/W CD
	MOV	AL,1			;  SET MODE FOR B/W CARD
	CMP	AH,30H			; B/W VIDEO CARD ATTACHED?
	JE	E9			; YES - GO TEST VIDEO STG
	MOV	BH,0B8H 		; BEG VIDEO RAM ADDR COLOR CD
	MOV	DL,0D8H 		; MODE REG FOR COLOR CD
	MOV	CH,40H			; RAM BYTE CNT FOR COLOR CD
	DEC	AL			; SET MODE TO 0 FOR COLOR CD
E9:					; TEST_VIDEO_STG:
	OUT	DX,AL			; DISABLE VIDEO FOR COLOR CD
	CMP	BP,1234H		; POD INITIATED BY KBD RESET?
	MOV	ES,BX			; POINT ES TO VIDEO RAM STG
	JE	E10			; YES - SKIP VIDEO RAM TEST
	MOV	DS,BX			; POINT DS TO VIDEO RAM STG
	CALL	STGTST_CNT		; GO TEST VIDEO R/W STG
	JNE	E17			; R/W STG FAILURE - BEEP SPK
;----------------------------------------------------------------
;	SETUP VIDEO DATA ON SCREEN FOR VIDEO LINE TEST. 	:
;DESCRIPTION							:
;	ENABLE VIDEO SIGNAL AND SET MODE.			:
;	DISPLAY A HORIZONTAL BAR ON SCREEN.			:
;----------------------------------------------------------------
E10:
	POP	AX			; GET VIDEO SENSE SWS (AH)
	PUSH	AX			; SAVE IT
	MOV	AH,0			; ENABLE VIDEO AND SET MODE
	INT	10H			; VIDEO
	MOV	AX,7020H		; WRT BLANKS IN REVERSE VIDEO
	SUB	DI,DI			; SETUP STARTING LOC
	MOV	CX,40			; NO. OF BLANKS TO DISPLAY
	REP	STOSW			; WRITE VIDEO STORAGE
;--------------------------------------------------------
;	CRT INTERFACE LINES TEST			:
;DESCRIPTION						:
;	SENSE ON/OFF TRANSITION OF THE VIDEO ENABLE	:
;	AND HORIZONTAL SYNC LINES.			:
;--------------------------------------------------------
	POP	AX			; GET VIDEO SENSE SW INFO
	PUSH	AX			; SAVE IT
	CMP	AH,30H			; B/W CARD ATTACHED?
	MOV	DX,03BAH		; SETUP ADDR OF BW STATUS PORT
	JE	E11			; YES - GO TEST LINES
	MOV	DL,0DAH 		; COLOR CARD IS ATTACHED
E11:					; LINE_TST:
	MOV	AH,8
E12:					; OFLOOP_CNT:
	SUB	CX,CX
E13:
	IN	AL,DX			; READ CRT STATUS PORT
	AND	AL,AH			; CHECK VIDEO/HORZ LINE
	JNZ	E14			; ITS ON - CHECK IF IT GOES OFF
	LOOP	E13			; LOOP TILL ON OR TIMEOUT
	JMP	SHORT E17		; GO PRINT ERROR MSG
E14:
	SUB	CX,CX
E15:
	IN	AL,DX			; READ CRT STATUS PORT
	AND	AL,AH			; CHECK VIDEO/HORZ LINE
	JZ	E16			; ITS ON - CHECK NEXT LINE
	LOOP	E15			; LOOP IF OFF TILL IT GOES ON
E17:					;  CRT_ERR:
	MOV	DX,102H
	CALL	ERR_BEEP		; GO BEEP SPEAKER
	JMP	SHORT E18
E16:					; NXT_LINE:
	MOV	CL,3			; GET NEXT BIT TO CHECK
	SHR	AH,CL			;
	JNZ	E12			; GO CHECK HORIZONTAL LINE
E18:					;  DISPLAY_CURSOR:
	POP	AX			; GET VIDEO SENSE SWS (AH)
	MOV	AH,0			; SET MODE AND DISPLAY CURSOR
	INT	10H			; CALL VIDEO I/O PROCEDURE

E18_1:
	MOV	DX,0C000H
E18A:
	MOV	DS,DX
	SUB	BX,BX
	MOV	AX,[BX] 		; GET FIRST 2 LOCATIONS
	PUSH	BX
	POP	BX			; LET BUS SETTLE
	CMP	AX,0AA55H		; PRESENT?
	JNZ	E18B			; NO? GO LOOK FOR OTHER MODULES
	CALL	ROM_CHECK		; GO SCAN MODULE
	JMP	SHORT E18C
E18B:
	ADD	DX,0080H		; POINT TO NEXT 2K BLOCK
E18C:
	CMP	DX,0C800H		; TOP OF VIDEO ROM AREA YET?
	JL	E18A			; GO SCAN FOR ANOTHER MODULE
;----------------------------------------------------------------
; EXPANSION I/O BOX TEST					:
;	CHECK TO SEE IF EXPANSION BOX PRESENT - IF INSTALLED,	:
;	TEST DATA AND ADDRESS BUSES TO I/O BOX. 		:
; ERROR='1801',                                                 :
;----------------------------------------------------------------

;----- DETERMINE IF BOX IS PRESENT

EXP_IO: 				; (CARD WAS ENABLED EARLIER)
	MOV	DX,0210H		; CONTROL PORT ADDRESS
	MOV	AX,5555H		; SET DATA PATTERN
	OUT	DX,AL
	MOV	AL,01H
	IN	AL,DX			; RECOVER DATA
	CMP	AL,AH			; REPLY?
	JNE	E19			; NO RESPONSE. GO TO NEXT TEST
	NOT	AX			; MAKE DATA=AAAA
	OUT	DX,AL
	MOV	AL,01H
	IN	AL,DX			; RECOVER DATA
	CMP	AL,AH
	JNE	E19			; NO ANSWER=NEXT TEST

;----- CHECK ADDRESS AND DATA BUS

EXP1:
	MOV	BX,AX
	MOV	DX,0214H		; LOAD DATA REG ADDRESS
	MOV	CS:[BX],AL		; WRITE ADDRESS F0000+BX
	OUT	DX,AL			; WRITE DATA
	NOP
	IN	AL,DX			; READ DATA
	CMP	AL,BH
	JNE	EXP_ERR
	INC	DX			; DX=215H (ADDR. HI REG)
	IN	AL,DX
	CMP	AL,AH			; COMPARE TO HI ADDRESS
	JNE	EXP_ERR
	INC	DX			; DX-216H (ADDR. LOW REG)
	IN	AL,DX
	CMP	AL,AH			; ADDR. LOW OK?
	JNE	EXP_ERR
	NOT	AX			; INVERT AX
	CMP	AL,0AAH 		; BACK TO STARTING VALUE (AAAA) YET
	JE	E19			; GO ON TO NEXT TEST IF SO
	JMP	SHORT EXP1		; LOOP BACK THROUGH WITH DATA OF 5555
EXP_ERR:
	MOV	SI,F3B
	NOP
	CALL	P_MSG
;----------------------------------------------------------------
;	ADDITIONAL READ/WRITE STORAGE TEST			:
;DESCRIPTION							:
;	WRITE/READ DATA PATTERNS TO ANY READ/WRITE STORAGE	:
;	AFTER THE BASIC 16K. STORAGE ADDRESSABILITY IS CHECKED. :
;----------------------------------------------------------------
E19:

;----- DETERMINE RAM SIZE ON PLANAR BOARD

	CALL	DDS
	MOV	AL,[BiosData.equipFlag]	; GET SENSE SWS INFO
	AND	AL,0CH			; ISOLATE RAM SIZE SWS
	MOV	AH,4
	MUL	AH
	ADD	AL,16			; ADD BASIC 16K
	MOV	DX,AX			; SAVE PLANAR RAM SIZE IN DX
	MOV	BX,AX			;  AND IN BX

;----- DETERMINE IO CHANNEL RAM SIZE

	MOV	AX,[BiosData.ioRamSize]	; GET IO CHANNEL RAM SIZE
	CMP	BX,BYTE 40H		; PLANAR RAM SIZE = 64K?
	JE	E20			; YES - ADD IO CHN RAM SIZE
	SUB	AX,AX			; NO - DON'T ADD ANY IO RAM
E20:					; ADD_IO_SIZE:
	ADD	AX,BX			; SUM TOTAL RAM SIZE
	MOV	[BiosData.memorySize],AX; SETUP MEMORY SIZE PARM
	CMP	BP,1234H		; POD INITIATED BY KBD RESET?
	PUSH	DS			; SAVE DATA SEGMENT
	JE	TST12			; YES - SKIP MEMORY TEST

;----- TEST ANY OTHER READ/WRITE STORAGE AVAILABLE

	MOV	BX,400H
	MOV	CX,16
E21:
	CMP	DX,CX			; ANY MORE STG TO BE TESTED?
	JBE	E23			; NO - GO TO NEXT TEST
	MOV	DS,BX			; SETUP STG ADDR IN DS AND ES
	MOV	ES,BX
	ADD	CX,BYTE 16		; INCREMENT STG BYTE COUNTER
	ADD	BX,400H 		; SET POINTER TO NEXT 16K BLK
	PUSH	CX			; SAVE REGS
	PUSH	BX
	PUSH	DX
	CALL	STGTST			; GO TEST A 16K BLK OF STG
	POP	DX
	POP	BX			; RESTORE REGS
	POP	CX
	JE	E21			; CHECK IF MORE STG TO TEST

;----- PRINT FAILING ADDRESS AND XOR'ED PATTERN IF DATA COMPARE ERROR

	MOV	DX,DS			; CONVERT FAILING HIGH-ORDER
	MOV	CH,AL			; SAVE FAILING BIT PATTERN
	MOV	AL,DH			; GET FAILING ADDR
	CALL	XPC_BYTE		; CONVERT AND PRINT CODE
	MOV	AL,CH
	CALL	XPC_BYTE		; CONVERT AND PRINT CODE
	MOV	SI,E1			; SETUP ADDRESS OF ERROR MSG
	NOP
	CALL	P_MSG			; PRINT ERROR MSG
E22:
	JMP	SHORT TST12		; GO TO NEXT TEST
E23:					; STG_TEST_DONE
	POP	DS			; POINT DS TO DATA SEGMENT
	PUSH	DS
	MOV	DX,[BiosData.ioRamSize]	; GET IO CHANNEL RAM SIZE
	OR	DX,DX			; SET FLAG RESULT
	JZ	TST12			; NO IO RAM, GO TO NEXT TEST
	MOV	CX,0
	CMP	BX,1000H		; HAS IO RAM BEEN TESTED
	JA	TST12			; YES - GO TO NEXT TEST
	MOV	BX,1000H		; SETUP BEG LOC FOR IO RAM
	JMP	SHORT E21		; GO TEST IO CHANNEL RAM
;--------------------------------------------------------
;	KEYBOARD TEST					:
;DESCRIPTION						:
;	RESET THE KEYBOARD AND CHECK THAT SCAN CODE	:
;	'AA' IS RETURNED TO THE CPU.  CHECK FOR STUCK   :
;	KEYS.						:
;--------------------------------------------------------
TST12:
	POP	DS
	CMP	BYTE [BiosData.mfgTest],1	; MANUFACTURING TEST MODE?
	JE	F7			; YES - SKIP KEYBOARD TEST
	CALL	KBD_RESET		; ISSUE SOFTWARE RESET TO KEYBRD
	JCXZ	F6			; PRINT ERR MSG IF NO INTERRUPT
	MOV	AL,4DH			; ENABLE KEYBOARD
	OUT	PORT_B,AL
	CMP	BL,0AAH 		; SCAN CODE AS EXPECTED?
	JNE	F6			; NO - DISPLAY ERROR MSG

;----- CHECK FOR STUCK KEYS

	MOV	AL,0CCH 		; CLR KBD, SET CLK LINE HIGH
	OUT	PORT_B,AL
	MOV	AL,4CH			; ENABLE KBD,CLK IN NEXT BYTE
	OUT	PORT_B,AL
	SUB	CX,CX
F5:					; KBD_WAIT:
	LOOP	F5			; DELAY FOR A WHILE
	IN	AL,KBD_IN		; CHECK FOR STUCK KEYS
	CMP	AL,0			; SCAN CODE = 0?
	JE	F7			; YES - CONTINUE TESTING
	CALL	XPC_BYTE		; CONVERT AND PRINT
F6:	MOV	SI,F1			; GET MSG ADDR
	NOP
	CALL	P_MSG			; PRINT MSG ON SCREEN

;----- SETUP INTERRUPT VECTOR TABLE

F7:					; SETUP_INT_TABLE:
	SUB	AX,AX
	MOV	ES,AX
	MOV	CX,8			; GET VECTOR CNT
	PUSH	DS			; SAVE DATA SEGMENT
	PUSH	CS			; SETUP DS SEG REG
	POP	DS
	MOV	SI,VECTOR_TABLE
	NOP
	MOV	DI,INT_PTR
F7A:
	MOVSW
	INC	DI			; SKIP OVER SEGMENT
	INC	DI
	LOOP	F7A
;--------------------------------------------------------
;	CASSETTE DATA WRAP TEST 			:
;DESCRIPTION						:
;	TURN CASSETTE MOTOR OFF. WRITE A BIT OUT TO THE :
;	CASSETTE DATA BUS. VERIFY THAT CASSETTE DATA	:
;	READ IS WITHIN A VALID RANGE.			:
;--------------------------------------------------------

;----- TURN THE CASSETTE MOTOR OFF

TST13:
	POP	DS
	PUSH	DS
	MOV	AL,04DH 		; SET TIMER 2 SPK OUT, AND CASST
	OUT	PORT_B,AL		; OUT BITS ON, CASSETTE MOT OFF

;----- WRITE A BIT

	MOV	AL,0FFH 		; DISABLE TIMER INTERRUPTS
	OUT	INTA01,AL
	MOV	AL,0B6H 		; SEL TIM 2, LSB, MSB, MD 3
	OUT	TIMER+3,AL		; WRITE 8253 CMD/MODE REG
	MOV	AX,1235 		; SET TIMER 2 CNT FOR 1000 USEC
	OUT	TIMER+2,AL		; WRITE TIMER 2 COUNTER REG
	MOV	AL,AH			; WRITE MSB
	OUT	TIMER+2,AL

;----- READ CASSETTE INPUT

	IN	AL,PORT_C		; READ VALUE OF CASS IN BIT
	AND	AL,10H			; ISOLATE FROM OTHER BITS
	MOV	[BiosData.lastVal],AL
	CALL	READ_HALF_BIT
	CALL	READ_HALF_BIT
	JCXZ	F8			; CAS_ERR
	CMP	BX,MAX_PERIOD
	JNC	F8			; CAS_ERR
	CMP	BX,MIN_PERIOD
	JNC	ROM_SCAN		; GO TO NEXT TEST IF OK
F8:					; CAS_ERR
	MOV	SI,F2			; CASSETTE WRAP FAILED
	NOP
	CALL	P_MSG			; GO PRINT ERROR MSG
;------------------------------------------------------------------------
;	CHECK FOR OPTIONAL ROM FROM C8000->F4000 IN 2K INCREMENTS	:
;	(A VALID MODULE HAS '55AA' IN THE FIRST 2 LOCATIONS, LENGTH     :
;	INDICATOR (LENGTH/512) IN THE 3RD LOCATION AND TEST/INIT.	:
;	CODE STARTING IN THE 4TH LOCATION.)				:
;------------------------------------------------------------------------
ROM_SCAN:
	MOV	DX,0C800H		; SET BEGINNING ADDRESS
ROM_SCAN_1:
	MOV	DS,DX
	SUB	BX,BX			; SET BX=0000
	MOV	AX,[BX] 		; GET 1ST WORD FROM MODULE
	CMP	AX,0AA55H		; = TO ID WORD?
	JNZ	NEXT_ROM		; PROCEED TO NEXT ROM IF NOT
	CALL	ROM_CHECK		; GO DO CHECKSUM AND CALL
	JMP	SHORT ARE_WE_DONE	; CHECK FOR END OF ROM SPACE
NEXT_ROM:
	ADD	DX,0080H		; POINT TO NEXT 2K ADDRESS
ARE_WE_DONE:
	CMP	DX,0F600H		; AT F6000 YET?
	JL	ROM_SCAN_1		; GO CHECK ANOTHER ADD. IF NOT
	JMP	SHORT BASE_ROM_CHK	; GO CHECK BASIC ROM
	NOP
;------------------------------------------------
;	ROS CHECKSUM II 			:
;DESCRIPTION					:
;	A CHECKSUM IS DONE FOR THE 4 ROS	:
;	MODULES CONTAINING BASIC CODE		:
;------------------------------------------------
BASE_ROM_CHK:
E4:
	SUB	BX,BX			; SETUP STARTING ROS ADDR
	MOV	DS,DX
	CALL	ROS_CHECKSUM		; CHECK ROS
	JE	E5			; CONTINUE IF OK
	CALL	ROM_ERR 		; POST ERROR
E5:
	ADD	DH,02H			; POINT TO NEXT 8K MODULE
	CMP	DH,0FEH
	JNZ	E4			; YES - CONTINUE
	POP	DS			; RECOVER DATA SEG PTR
;------------------------------------------------------------------------
;	DISKETTE ATTACHMENT TEST					:
;DESCRIPTION								:
;	CHECK IF IPL DISKETTE DRIVE IS ATTACHED TO SYSTEM. IF ATTACHED, :
;	VERIFY STATUS OF NEC FDC AFTER A RESET. ISSUE A RECAL AND SEEK	:
;	CMD TO FDC AND CHECK STATUS. COMPLETE SYSTEM INITIALIZATION	:
;	THEN PASS CONTROL TO THE BOOT LOADER PROGRAM.			:
;------------------------------------------------------------------------
F9:
	MOV	AL,[BiosData.equipFlag]		; GET SENSE SWS INFO
	TEST	AL,01H			; IPL DISKETTE DRIVE ATTCH?
	JNZ	F10			; NO -SKIP THIS TEST
	CMP	BYTE [BiosData.mfgTest],1	; MANUFACTURING TEST MODE?
	JNE	F15A			; NO - GO TO BOOT LOADER
	JMP	START			; YES - LOOP POWER-ON-DIAGS
F10:
	IN	AL,INTA01		; DISK_TEST:
	AND	AL,0BFH 		; ENABLE DISKETTE INTERRUPTS
	OUT	INTA01,AL
	MOV	AH,0			; RESET NEC FDC
	MOV	DL,AH			; (POINT TO DISKETTE)
	INT	13H			; VERIFY STATUS AFTER RESET
	JC	F13

;----- TURN DRIVE 0 MOTOR ON

	MOV	DX,03F2H		; GET ADDR OF FDC CARD
	PUSH	DX			; SAVE IT
	MOV	AL,1CH			; TURN MOTOR ON, EN DMA/INT
	OUT	DX,AL			; WRITE FDC CONTROL REG
	SUB	CX,CX
F11:					; MOTOR_WAIT:
	LOOP	F11			; WAIT FOR 1 SECOND
F12:					; MOTOR_WAIT1:
	LOOP	F12
	XOR	DX,DX			; SELECT DRIVE 0
	MOV	CH,1			; SELECT TRACK 1
	MOV	[BiosData.seekStatus],DL
	CALL	SEEK			; RECALIBRATE DISKETTE
	JC	F13			; GO TO ERR SUBROUTINE IF ERR
	MOV	CH,34			; SELECT TRACK 34
	CALL	SEEK			; SEEK TO TRACK 34
	JNC	F14			; OK, TURN MOTOR OFF
F13:					; DSK_ERR:
	MOV	SI,F3			; GET ADDR OF MSG
	NOP
	CALL	P_MSG			; GO PRINT ERROR MSG

;----- TURN DRIVE 0 MOTOR OFF

F14:					; DR0_OFF:
	MOV	AL,0CH			; TURN DRIVE 0 MOTOR OFF
	POP	DX			; RECOVER FDC CTL ADDRESS
	OUT	DX,AL

;----- SETUP PRINTER AND RS232 BASE ADDRESSES IF DEVICE ATTACHED

F15A:
	MOV	SI,BiosData.kbBuffer
	MOV	[BiosData.bufferHead],SI; SETUP KEYBOARD PARAMETERS
	MOV	[BiosData.bufferTail],SI
	MOV	[BiosData.bufferStart],SI
	ADD	SI,BYTE 32
	MOV	[BiosData.bufferEnd],SI
	IN	AL,INTA01
	AND	AL,0FCH 		; ENABLE TIMER AND KBD INTS
	OUT	INTA01,AL
	MOV	BP,F4			; PRT_SRC_TBL
	NOP
	SUB	SI,SI
F16:					; PRT_BASE:
	CS MOV	DX,[BP]			; GET PRINTER BASE ADDR
	MOV	AL,0AAH 		; WRITE DATA TO PORT A
	OUT	DX,AL
	PUSH	DX
	IN	AL,DX			; READ PORT A
	POP	DX
	CMP	AL,0AAH 		; DATA PATTERN SAME
	JNE	F17			; NO - CHECK NEXT PRT CD
	MOV	[SI+BiosData.printerBase],DX	; YES - STORE PRT BASE ADDR
	INC	SI			; INCREMENT TO NEXT WORD
	INC	SI
F17:					; NO_STORE:
	INC	BP			; POINT TO NEXT BASE ADDR
	INC	BP
	CMP	BP,F4E			; ALL POSSIBLE ADDRS CHECKED?
	JNE	F16			; PRT_BASE
	SUB	BX,BX			; POINTER TO RS232 TABLE
	MOV	DX,3FAH 		; CHECK IF RS232 CD 1 ATTCH?
	IN	AL,DX			; READ INTR ID REG
	TEST	AL,0F8H
	JNZ	F18
	MOV	WORD [BX+BiosData.rs232Base],3F8H	; SETUP RS232 CD #1 ADDR
	INC	BX
	INC	BX
F18:
	MOV	DH,02H			; CHECK IF RS232 CD 2 ATTCH (AT 2FA)
	IN	AL,DX			; READ INTERRUPT ID REG
	TEST	AL,0F8H
	JNZ	F19			; BASE_END
	MOV	WORD [BX+BiosData.rs232Base],2F8H	; SETUP RS232 CD #2
	INC	BX
	INC	BX

;----- SET UP EQUIP FLAG TO INDICATE NUMBER OF PRINTERS AND RS232 CARDS

F19:					; BASE_END:
	MOV	AX,SI			; SI HAS 2* NUMBER OF RS232
	MOV	CL,3			; SHIFT COUNT
	ROR	AL,CL			; ROTATE RIGHT 3 POSITIONS
	OR	AL,BL			; OR IN THE PRINTER COUNT
	MOV	[BiosData.equipFlag+1],AL	; STORE AS SECOND BYTE
	MOV	DL,01H			; DX=201
	IN	AL,DX
	TEST	AL,0FH
	JNZ	F20			; NO_GAME_CARD
	OR	BYTE [BiosData.equipFlag+1],16
F20:

;----- SET DEFAULT TIMEOUT VALUES FOR PRINTER AND RS232

	PUSH	DS
	POP	ES
	MOV	DI,BiosData.printerTimeOut
	MOV	AX,1414H
	STOSW
	STOSW
	MOV	AX,0101H
	STOSW
	STOSW

;----- ENABLE NMI INTERRUPTS

	MOV	AL,80H			; ENABLE NMI INTERRUPTS
	OUT	0A0H,AL
	CMP	BYTE [BiosData.mfgTest],1	; MFG MODE?
	JE	F21			; LOAD_BOOT_STRAP
	MOV	DX,1
	CALL	ERR_BEEP		; BEEP 1 SHORT TONE

F21:					; LOAD_BOOT_STRAP:
	INT	19H			; BOOTSTRAP

;--------------------------------------------------------
;	INITIAL RELIABILITY TEST -- SUBROUTINES 	:
;--------------------------------------------------------

;------------------------------------------------------------------------
; SUBROUTINES FOR POWER ON DIAGNOSTICS					:
;	THIS PROCEDURE WILL ISSUE ONE LONG TONE (3 SECS) AND ONE OR	:
;	MORE SHORT TONES (1 SEC) TO INDICATE A FAILURE ON THE PLANAR	:
;	BOARD, A BAD RAM MODULE, OR A PROBLEM WITH THE CRT.		:
;ENTRY PARAMETERS:							:
;	DH = NUMBER OF LONG TONES TO BEEP				:
;	DL = NUMBER OF SHORT TONES TO BEEP				:
;------------------------------------------------------------------------
ERR_BEEP:
	PUSHF				; SAVE FLAGS
	CLI				; DISABLE SYSTEM INTERRUPTS
	PUSH	DS			; SAVE DS REG CONTENTS
	CALL	DDS
	OR	DH,DH			; ANY LONG ONES TO BEEP
	JZ	G3			; NO, DO THE SHORT ONES
G1:					; LONG_BEEP:
	MOV	BL,6			; COUNTER FOR BEEPS
	CALL	BEEP			; DO THE BEEP
G2:	LOOP	G2			; DELAY BETWEEN BEEPS
	DEC	DH			; ANY MORE TO DO
	JNZ	G1			; DO IT
	CMP	BYTE [BiosData.mfgTest],1	; MFG TEST MODE?
	JNE	G3			; YES - CONTINUE BEEPING SPEAKER
	MOV	AL,0CDH 		; STOP BLINKING LED
	OUT	PORT_B,AL
	JMP	SHORT G1
G3:					; SHORT_BEEP:
	MOV	BL,1			; COUNTER FOR A SHORT BEEP
	CALL	BEEP			; DO THE SOUND
G4:
	LOOP	G4			; DELAY BETWEEN BEEPS
	DEC	DL			; DONE WITH SHORTS
	JNZ	G3			; DO SOME MORE
G5:
	LOOP	G5			; LONG DELAY BEFORE RETURN
G6:
	LOOP	G6
	POP	DS			; RESTORE ORIG CONTENTS OF DS
	POPF				; RESTORE FLAGS TO ORIG SETTINGS
	RET				; RETURN TO CALLER

;----- ROUTINE TO SOUND BEEPER

BEEP:
	MOV	AL,10110110B		; SEL TIM 2,LSB,MSB,BINARY
	OUT	TIMER+3,AL		; WRITE THE TIMER MODE REG
	MOV	AX,533H 		; DIVISOR FOR 1000 HZ
	OUT	TIMER+2,AL		; WRITE TIMER 2 CNT - LSB
	MOV	AL,AH
	OUT	TIMER+2,AL		; WRITE TIMER 2 CNT - MSB
	IN	AL,PORT_B		; GET CURRENT SETTING OF PORT
	MOV	AH,AL			; SAVE THAT SETTING
	OR	AL,03			; TURN SPEAKER ON
	OUT	PORT_B,AL
	SUB	CX,CX			; SET CNT TO WAIT 500 MS
G7:
	LOOP	G7			; DELAY BEFORE TURNING OFF
	DEC	BL			; DELAY CNT EXPIRED?
	JNZ	G7			; NO - CONTINUE BEEPING SPK
	MOV	AL,AH			; RECOVER VALUE OF PORT
	OUT	PORT_B,AL
	RET				; RETURN TO CALLER

;------------------------------------------------
; CONVERT AND PRINT ASCII CODE			:
;	AL MUST CONTAIN NUMBER TO BE CONVERTED. :
;	AX AND BX DESTROYED.			:
;------------------------------------------------
XPC_BYTE:
	PUSH	AX			; RESAVE FOR LOW NYBBLE DISPLAY
	MOV	CL,4			; SHIFT COUNT
	SHR	AL,CL			; NIBBLE SWAP
	CALL	XLAT_PR 		; DO THE HIGH NIBBLE DISPLAY
	POP	AX			; RECOVER THE NIBBLE
	AND	AL,0FH			; ISOLATE TO LOW NIBBLE
					; FALL INTO NIBBLE CONVERSION
XLAT_PR:				; CONVERT 00-0F TO ASCII CHARACTER
	ADD	AL,090H 		; ADD FIRST CONVERSION FACTOR
	DAA				; ADJUST FOR NUMERIC AND ALPHA RANGE
	ADC	AL,040H 		; ADD CONVERSION AND ADJUST LOW NIBBLE
	DAA				; ADJUST HI NIBBLE TO ASCII RANGE
PRT_HEX:
	MOV	AH,14			; DISPLAY CHAR. IN AL
	MOV	BH,0
	INT	10H			; CALL VIDEO_IO
	RET

F4:					; PRINTER SOURCE TABLE
	DW	3BCH
	DW	378H
	DW	278H
F4E	EQU	$

;------------------------------------------------------------------------
;	THIS PROCEDURE WILL SEND A SOFTWARE RESET TO THE KEYBOARD.	:
;	SCAN CODE 'AA' SHOULD BE RETURNED TO THE CPU.                   :
;------------------------------------------------------------------------
KBD_RESET:
	MOV	AL,0CH			; SET KBD CLK LINE LOW
	OUT	PORT_B,AL		; WRITE 8255 PORT B
	MOV	CX,10582		; HOLD KBD CLK LOW FOR 20 MS
G8:
	LOOP	G8			; LOOP FOR 20 MS
	MOV	AL,0CCH 		; SET CLK, ENABLE LINES HIGH
	OUT	PORT_B,AL
SP_TEST:				; ENTRY FOR MANUFACTURING TEST 2
	MOV	AL,4CH			; SET KBD CLK HIGH, ENABLE LOW
	OUT	PORT_B,AL
	MOV	AL,0FDH 		; ENABLE KEYBOARD INTERRUPTS
	OUT	INTA01,AL		; WRITE 8255 IMR
	STI				; ENABLE SYSTEM INTERRUPTS
	MOV	AH,0			; RESET INTERRUPT INDICATOR
	SUB	CX,CX			; SETUP INTERRUPT TIMEOUT CNT
G9:
	TEST	AH,0FFH 		; DID A KEYBOARD INTR OCCUR?
	JNZ	G10			; YES - READ SCAN CODE RETURNED
	LOOP	G9			; NO - LOOP TILL TIMEOUT
G10:
	IN	AL,PORT_A		; READ KEYBOARD SCAN CODE
	MOV	BL,AL			; SAVE SCAN CODE JUST READ
	MOV	AL,0CCH 		; CLEAR KEYBOARD
	OUT	PORT_B,AL
	RET				; RETURN TO CALLER

;------------------------------------------------------------------------
;	BLINK LED PROCEDURE FOR MFG BURN-IN AND RUN-IN TESTS		:
;	IF LED IS ON, TURN IT OFF. IF OFF, TURN ON.			:
;------------------------------------------------------------------------
BLINK_INT:
	STI
	PUSH	AX			; SAVE AX REG CONTENTS
	IN	AL,PORT_B		; READ CURRENT VAL OF PORT B
	MOV	AH,AL
	NOT	AL			; FLIP ALL BITS
	AND	AL,01000000B		; ISOLATE CONTROL BIT
	AND	AH,10111111B		; MASK OUT OF ORIGINAL VAL
	OR	AL,AH			; OR NEW CONTROL BIT IN
	OUT	PORT_B,AL
	MOV	AL,EOI
	OUT	INTA00,AL
	POP	AX			; RESTORE AX REG
	IRET

;----- CHECKSUM AND CALL INIT CODE IN OPTIONAL ROMS

ROM_CHECK:
	MOV	AX,DATA 		; SET ES=DATA
	MOV	ES,AX
	SUB	AH,AH			; ZERO OUT AH
	MOV	AL,[BX+2]		; GET LENGTH INDICATOR
	MOV	CL,09H			; MULTIPLY BY 512
	SHL	AX,CL
	MOV	CX,AX			; SET COUNT
	PUSH	CX
	MOV	CL,4
	SHR	AX,CL
	ADD	DX,AX			; SET POINTER TO NEXT MODULE
	POP	CX

	CALL	ROS_CHECKSUM_CNT	; DO CHECKSUM
	JZ	ROM_CHECK_1
	CALL	ROM_ERR 		; PRINT ERROR INFO
	JMP	SHORT ROM_CHECK_END
ROM_CHECK_1:
	PUSH	DX			; SAVE POINTER
	ES MOV	WORD [IO_ROM_INIT],0003H; LOAD OFFSET
	ES MOV	[IO_ROM_SEG],DS		; LOAD SEGMENT
	ES CALL	FAR [IO_ROM_INIT]	; CALL INIT RTN.
	POP	DX
ROM_CHECK_END:
	RET

;----------------------------------------------------------------
;	THIS SUBROUTINE WILL PRINT A MESSAGE ON THE DISPLAY	:
;								:
;ENTRY REQUIREMENTS:						:
;	SI = OFFSET(ADDRESS) OF MESSAGE BUFFER			:
;	CX = MESSAGE BYTE COUNT 				:
;	MAXIMUM MESSAGE LENGTH IS 36 CHARACTERS 		:
;----------------------------------------------------------------
P_MSG:
	CALL	DDS
	CMP	BYTE [BiosData.mfgTest],1	; MFG TEST MODE?
	JNE	G12			; NO - DISPLAY ERROR MSG
	MOV	DH,1			; YES - SETUP TO BEEP SPEAKER
	JMP	ERR_BEEP		; YES - BEEP SPEAKER
G12:					; WRITE_MSG:
	CS MOV	AL,[SI]			; PUT CHAR IN AL
	INC	SI			; POINT TO NEXT CHAR
	PUSH	AX			; SAVE PRINT CHAR
	CALL	PRT_HEX 		; CALL VIDEO_IO
	POP	AX			; RECOVER PRINT CHAR
	CMP	AL,10			; WAS IT LINE FEED?
	JNE	G12			; NO,KEEP PRINTING STRING
	RET

F3A:
	DB	' ROM',13,10

D_EOI:
	PUSH	AX
	MOV	AL,20H
	OUT	20H,AL
	POP	AX
	IRET

	%include "bootstrap.inc"
	%include "rs232.inc"

;------------------------------------------------------------------------
;	PRINT ADDRESS AND ERROR MESSAGE FOR ROM CHECKSUM ERRORS 	:
;------------------------------------------------------------------------
ROM_ERR:
	PUSH	DX			; SAVE POINTER
	PUSH	AX
	MOV	DX,DS			; GET ADDRESS POINTER
	CMP	DX,0C800H
	JLE	ROM_ERR_BEEP		; SPECIAL ERROR INDICATION
	MOV	AL,DH
	CALL	XPC_BYTE		; DISPLAY ADDRESS
	MOV	AL,DL
	CALL	XPC_BYTE
	MOV	SI,F3A			; DISPLAY ERROR MSG
	CALL	P_MSG
ROM_ERR_END:
	POP	AX
	POP	DX
	RET
ROM_ERR_BEEP:
	MOV	DX,0102H		; BEEP 1 LONG, 2 SHORT
	CALL	ERR_BEEP
	JMP	SHORT ROM_ERR_END

	%include "keyboard.inc"
	%include "diskette.inc"
	%include "printer.inc"

C2:
	DW	C24			; RETURN ADDRESS FOR DUMMY STACK

	%include "video.inc"

;--- INT 12 -------------------------------------------------------------
; MEMORY_SIZE_DET							:
;	THIS ROUTINE DETERMINES THE AMOUNT OF MEMORY IN THE SYSTEM	:
;	AS REPRESENTED BY THE SWITCHES ON THE PLANAR. NOTE THAT THE	:
;	SYSTEM MAY NOT BE ABLE TO USE I/O MEMORY UNLESS THERE IS A FULL :
;	COMPLEMENT OF 64K BYTES ON THE PLANAR.				:
; INPUT 								:
;	NO REGISTERS							:
;	THE MEMORY_SIZE VARIABLE IS SET DURING POWER ON DIAGNOSTICS	:
;	 ACCORDING TO THE FOLLOWING HARDWARE ASSUMPTIONS:		:
;	PORT 60 BITS 3,2 = 00 - 16K BASE RAM				:
;			   01 - 32K BASE RAM				:
;			   10 - 48K BASE RAM				:
;			   11 - 64K BASE RAM				:
;	PORT 62 BITS 3-0 INDICATE AMOUNT OF I/O RAM IN 32K INCREMENTS	:
;		E.G., 0000 - NO RAM IN I/O CHANNEL			:
;		      0010 - 64K RAM IN I/O CHANNEL, ETC.		:
; OUTPUT								:
;	(AX) = NUMBER OF CONTIGUOUS 1K BLOCKS OF MEMORY 		:
;------------------------------------------------------------------------
	TIMES	0F841H-($-$$) DB 0FFh
MEMORY_SIZE_DET:
	STI				; INTERRUPTS BACK ON
	PUSH	DS			; SAVE SEGMENT
	CALL	DDS
	MOV	AX,[BiosData.memorySize]; GET VALUE
	POP	DS			; RECOVER SEGMENT
	IRET				; RETURN TO CALLER

;--- INT 11 -----------------------------------------------------
; EQUIPMENT DETERMINATION					:
;	THIS ROUTINE ATTEMPTS TO DETERMINE WHAT OPTIONAL	:
;	DEVICES ARE ATTACHED TO THE SYSTEM.			:
; INPUT 							:
;	NO REGISTERS						:
;	THE EQUIP_FLAG VARIABLE IS SET DURING THE POWER ON	:
;	DIAGNOSTICS USING THE FOLLOWING HARDWARE ASSUMPTIONS:	:
;	PORT 60  = LOW ORDER BYTE OF EQUIPMENT			:
;	PORT 3FA = INTERRUPT ID REGISTER OF 8250		:
;		BITS 7-3 ARE ALWAYS 0				:
;	PORT 378 = OUTPUT PORT OF PRINTER -- 8255 PORT THAT	:
;		CAN BE READ AS WELL AS WRITTEN			:
; OUTPUT							:
;	(AX) IS SET, BIT SIGNIFICANT, TO INDICATE ATTACHED I/O	:
;	BIT 15,14 = NUMBER OF PRINTERS ATTACHED 		:
;	BIT 13 NOT USED 					:
;	BIT 12 = GAME I/O ATTACHED				:
;	BIT 11,10,9 = NUMBER OF RS232 CARDS ATTACHED		:
;	BIT 8 UNUSED						:
;	BIT 7,6 = NUMBER OF DISKETTE DRIVES			:
;		00=1, 01=2, 10-3, 11=4 ONLY IF BIT 0 = 1	:
;	BIT 5,4 = INITIAL VIDEO MODE				:
;			00 - UNUSED				:
;			01 - 40X25 BW USING COLOR CARD		:
;			10 - 80X25 BW USING COLOR CARD		:
;			11 - 80X25 BW USING BW CARD		:
;	BIT 3,2 = PLANAR RAM SIZE (00=16K,01=32K,10=48K,11=64K) :
;	BIT 1 NOT USED						:
;	BIT 0 = IPL FROM DISKETTE -- THIS BIT INDICATES THAT	:
;		THERE ARE DISKETTE DRIVES ON THE SYSTEM 	:
;								:
;	NO OTHER REGISTERS AFFECTED				:
;----------------------------------------------------------------
	TIMES	0F84DH-($-$$) DB 0FFh
EQUIPMENT:
	STI			; INTERRUPTS BACK ON
	PUSH	DS		; SAVE SEGMENT REGISTER
	CALL	DDS
	MOV	AX,[BiosData.equipFlag]	; GET THE CURRENT SETTINGS
	POP	DS		; RECOVER SEGMENT
	IRET			; RETURN TO CALLER

	%include "cassette.inc"

E1	DB	' 201',13,10

;-----------------------------------------------------------------------
;	CHARACTER GENERATOR GRAPHICS FOR 320X200 AND 640X200 GRAPHICS
;-----------------------------------------------------------------------
	TIMES	0FA6EH-($-$$) DB 0FFh
CRT_CHAR_GEN:
	DB	000H,000H,000H,000H,000H,000H,000H,000H ; D_00
	DB	07EH,081H,0A5H,081H,0BDH,099H,081H,07EH ; D_01
	DB	07EH,0FFH,0DBH,0FFH,0C3H,0E7H,0FFH,07EH ; D_02
	DB	06CH,0FEH,0FEH,0FEH,07CH,038H,010H,000H ; D_03
	DB	010H,038H,07CH,0FEH,07CH,038H,010H,000H ; D_04
	DB	038H,07CH,038H,0FEH,0FEH,07CH,038H,07CH ; D_05
	DB	010H,010H,038H,07CH,0FEH,07CH,038H,07CH ; D_06
	DB	000H,000H,018H,03CH,03CH,018H,000H,000H ; D_07
	DB	0FFH,0FFH,0E7H,0C3H,0C3H,0E7H,0FFH,0FFH ; D_08
	DB	000H,03CH,066H,042H,042H,066H,03CH,000H ; D_09
	DB	0FFH,0C3H,099H,0BDH,0BDH,099H,0C3H,0FFH ; D_0A
	DB	00FH,007H,00FH,07DH,0CCH,0CCH,0CCH,078H ; D_08
	DB	03CH,066H,066H,066H,03CH,018H,07EH,018H ; D_0C
	DB	03FH,033H,03FH,030H,030H,070H,0F0H,0E0H ; D_0D
	DB	07FH,063H,07FH,063H,063H,067H,0E6H,0C0H ; D_0E
	DB	099H,05AH,03CH,0E7H,0E7H,03CH,05AH,099H ; D_0F
	DB	080H,0E0H,0F8H,0FEH,0F8H,0E0H,080H,000H ; D_10
	DB	002H,00EH,03EH,0FEH,03EH,00EH,002H,000H ; D_11
	DB	018H,03CH,07EH,018H,018H,07EH,03CH,018H ; D_12
	DB	066H,066H,066H,066H,066H,000H,066H,000H ; D_13
	DB	07FH,0DBH,0DBH,07BH,01BH,01BH,01BH,000H ; D_14
	DB	03EH,063H,038H,06CH,06CH,038H,0CCH,078H ; D_15
	DB	000H,000H,000H,000H,07EH,07EH,07EH,000H ; D_16
	DB	018H,03CH,07EH,018H,07EH,03CH,018H,0FFH ; D_17
	DB	018H,03CH,07EH,018H,018H,018H,018H,000H ; D_18
	DB	018H,018H,018H,018H,07EH,03CH,018H,000H ; D_19
	DB	000H,018H,00CH,0FEH,00CH,018H,000H,000H ; D_1A
	DB	000H,030H,060H,0FEH,060H,030H,000H,000H ; D_1B
	DB	000H,000H,0C0H,0C0H,0C0H,0FEH,000H,000H ; D_1C
	DB	000H,024H,066H,0FFH,066H,024H,000H,000H ; D_1D
	DB	000H,018H,03CH,07EH,0FFH,0FFH,000H,000H ; D_1E
	DB	000H,0FFH,0FFH,07EH,03CH,018H,000H,000H ; D_1F
	DB	000H,000H,000H,000H,000H,000H,000H,000H ; SP D_20
	DB	030H,078H,078H,030H,030H,000H,030H,000H ; ! D_21
	DB	06CH,06CH,06CH,000H,000H,000H,000H,000H ; " D_22
	DB	06CH,06CH,0FEH,06CH,0FEH,06CH,06CH,000H ; # D_23
	DB	030H,07CH,0C0H,078H,00CH,0F8H,030H,000H ; $ D_24
	DB	000H,0C6H,0CCH,018H,030H,066H,0C6H,000H ; PER CENT D_25
	DB	038H,06CH,038H,076H,0DCH,0CCH,076H,000H ; & D_26
	DB	060H,060H,0C0H,000H,000H,000H,000H,000H ; ' D_27
	DB	018H,030H,060H,060H,060H,030H,018H,000H ; ( D_28
	DB	060H,030H,018H,018H,018H,030H,060H,000H ; ) D_29
	DB	000H,066H,03CH,0FFH,03CH,066H,000H,000H ; * D_2A
	DB	000H,030H,030H,0FCH,030H,030H,000H,000H ; + D_2B
	DB	000H,000H,000H,000H,000H,030H,030H,060H ; , D_2C
	DB	000H,000H,000H,0FCH,000H,000H,000H,000H ; - D_2D
	DB	000H,000H,000H,000H,000H,030H,030H,000H ; . D_2E
	DB	006H,00CH,018H,030H,060H,0C0H,080H,000H ; / D_2F
	DB	07CH,0C6H,0CEH,0DEH,0F6H,0E6H,07CH,000H ; 0 D_30
	DB	030H,070H,030H,030H,030H,030H,0FCH,000H ; 1 D_31
	DB	078H,0CCH,00CH,038H,060H,0CCH,0FCH,000H ; 2 D_32
	DB	078H,0CCH,00CH,038H,00CH,0CCH,078H,000H ; 3 D_33
	DB	01CH,03CH,06CH,0CCH,0FEH,00CH,01EH,000H ; 4 D_34
	DB	0FCH,0C0H,0F8H,00CH,00CH,0CCH,078H,000H ; 5 D_35
	DB	038H,060H,0C0H,0F8H,0CCH,0CCH,078H,000H ; 6 D_36
	DB	0FCH,0CCH,00CH,018H,030H,030H,030H,000H ; 7 D_37
	DB	078H,0CCH,0CCH,078H,0CCH,0CCH,078H,000H ; 8 D_38
	DB	078H,0CCH,0CCH,07CH,00CH,018H,070H,000H ; 9 D_39
	DB	000H,030H,030H,000H,000H,030H,030H,000H ; : D_3A
	DB	000H,030H,030H,000H,000H,030H,030H,060H ; ; D_3B
	DB	018H,030H,060H,0C0H,060H,030H,018H,000H ; < D_3C
	DB	000H,000H,0FCH,000H,000H,0FCH,000H,000H ; = D_3D
	DB	060H,030H,018H,00CH,018H,030H,060H,000H ; > D_3E
	DB	078H,0CCH,00CH,018H,030H,000H,030H,000H ; ? D_3F
	DB	07CH,0C6H,0DEH,0DEH,0DEH,0C0H,078H,000H ; @ D_40
	DB	030H,078H,0CCH,0CCH,0FCH,0CCH,0CCH,000H ; A D_41
	DB	0FCH,066H,066H,07CH,066H,066H,0FCH,000H ; B D_42
	DB	03CH,066H,0C0H,0C0H,0C0H,066H,03CH,000H ; C D_43
	DB	0F8H,06CH,066H,066H,066H,06CH,0F8H,000H ; D D_44
	DB	0FEH,062H,068H,078H,068H,062H,0FEH,000H ; E D_45
	DB	0FEH,062H,068H,078H,068H,060H,0F0H,000H ; F D_46
	DB	03CH,066H,0C0H,0C0H,0CEH,066H,03EH,000H ; G D_47
	DB	0CCH,0CCH,0CCH,0FCH,0CCH,0CCH,0CCH,000H ; H D_48
	DB	078H,030H,030H,030H,030H,030H,078H,000H ; I D_49
	DB	01EH,00CH,00CH,00CH,0CCH,0CCH,078H,000H ; J D_4A
	DB	0E6H,066H,06CH,078H,06CH,066H,0E6H,000H ; K D_4B
	DB	0F0H,060H,060H,060H,062H,066H,0FEH,000H ; L D_4C
	DB	0C6H,0EEH,0FEH,0FEH,0D6H,0C6H,0C6H,000H ; M D_4C
	DB	0C6H,0E6H,0F6H,0DEH,0CEH,0C6H,0C6H,000H ; N D_4E
	DB	038H,06CH,0C6H,0C6H,0C6H,06CH,038H,000H ; O D_4F
	DB	0FCH,066H,066H,07CH,060H,060H,0F0H,000H ; P D_50
	DB	078H,0CCH,0CCH,0CCH,0DCH,078H,01CH,000H ; Q D_51
	DB	0FCH,066H,066H,07CH,06CH,066H,0E6H,000H ; R D_52
	DB	078H,0CCH,0E0H,070H,01CH,0CCH,078H,000H ; S D_53
	DB	0FCH,0B4H,030H,030H,030H,030H,078H,000H ; T D_54
	DB	0CCH,0CCH,0CCH,0CCH,0CCH,0CCH,0FCH,000H ; U D_55
	DB	0CCH,0CCH,0CCH,0CCH,0CCH,078H,030H,000H ; V D_56
	DB	0C6H,0C6H,0C6H,0D6H,0FEH,0EEH,0C6H,000H ; W D_57
	DB	0C6H,0C6H,06CH,038H,038H,06CH,0C6H,000H ; X D_58
	DB	0CCH,0CCH,0CCH,078H,030H,030H,078H,000H ; Y D_59
	DB	0FEH,0C6H,08CH,018H,032H,066H,0FEH,000H ; Z D_5A
	DB	078H,060H,060H,060H,060H,060H,078H,000H ; [ D_5B
	DB	0C0H,060H,030H,018H,00CH,006H,002H,000H ; BACKSLASH D_5C
	DB	078H,018H,018H,018H,018H,018H,078H,000H ; ] D_5D
	DB	010H,038H,06CH,0C6H,000H,000H,000H,000H ; CIRCUMFLEX D_5E
	DB	000H,000H,000H,000H,000H,000H,000H,0FFH ; _ D_5F
	DB	030H,030H,018H,000H,000H,000H,000H,000H ;   D_60
	DB	000H,000H,078H,00CH,07CH,0CCH,076H,000H ; LOWER CASE A D_61
	DB	0E0H,060H,060H,07CH,066H,066H,0DCH,000H ; L.C. B D_62
	DB	000H,000H,078H,0CCH,0C0H,0CCH,078H,000H ; L.C. C D_63
	DB	01CH,00CH,00CH,07CH,0CCH,0CCH,076H,000H ; L.C. D D_64
	DB	000H,000H,078H,0CCH,0FCH,0C0H,078H,000H ; L.C. E D_65
	DB	038H,06CH,060H,0F0H,060H,060H,0F0H,000H ; L.C. F D_66
	DB	000H,000H,076H,0CCH,0CCH,07CH,00CH,0F8H ; L.C. G D_67
	DB	0E0H,060H,06CH,076H,066H,066H,0E6H,000H ; L.C. H D_68
	DB	030H,000H,070H,030H,030H,030H,078H,000H ; L.C. I D_69
	DB	00CH,000H,00CH,00CH,00CH,0CCH,0CCH,078H ; L.C. J D_6A
	DB	0E0H,060H,066H,06CH,078H,06CH,0E6H,000H ; L.C. K D_6B
	DB	070H,030H,030H,030H,030H,030H,078H,000H ; L.C. L D_6C
	DB	000H,000H,0CCH,0FEH,0FEH,0D6H,0C6H,000H ; L.C. M D_6D
	DB	000H,000H,0F8H,0CCH,0CCH,0CCH,0CCH,000H ; L.C. N D_6E
	DB	000H,000H,078H,0CCH,0CCH,0CCH,078H,000H ; L.C. O D_6F
	DB	000H,000H,0DCH,066H,066H,07CH,060H,0F0H ; L.C. P D_70
	DB	000H,000H,076H,0CCH,0CCH,07CH,00CH,01EH ; L.C. Q D_71
	DB	000H,000H,0DCH,076H,066H,060H,0F0H,000H ; L.C. R D_72
	DB	000H,000H,07CH,0C0H,078H,00CH,0F8H,000H ; L.C. S D_73
	DB	010H,030H,07CH,030H,030H,034H,018H,000H ; L.C. T D_74
	DB	000H,000H,0CCH,0CCH,0CCH,0CCH,076H,000H ; L.C. U D_75
	DB	000H,000H,0CCH,0CCH,0CCH,078H,030H,000H ; L.C. V D_76
	DB	000H,000H,0C6H,0D6H,0FEH,0FEH,06CH,000H ; L.C. W D_77
	DB	000H,000H,0C6H,06CH,038H,06CH,0C6H,000H ; L.C. X D_78
	DB	000H,000H,0CCH,0CCH,0CCH,07CH,00CH,0F8H ; L.C. Y D_79
	DB	000H,000H,0FCH,098H,030H,064H,0FCH,000H ; L.C. Z D_7A
	DB	01CH,030H,030H,0E0H,030H,030H,01CH,000H ; { D_7B
	DB	018H,018H,018H,000H,018H,018H,018H,000H ; | D_7C
	DB	0E0H,030H,030H,01CH,030H,030H,0E0H,000H ; } D_7D
	DB	076H,0DCH,000H,000H,000H,000H,000H,000H ; TILDE D_7E
	DB	000H,010H,038H,06CH,0C6H,0C6H,0FEH,000H ; DELTA D_7F

;--- INT 1A ---------------------------------------------
; TIME_OF_DAY						:
;  THIS ROUTINE ALLOWS THE CLOCK TO BE SET/READ 	:
;							:
; INPUT 						:
;   (AH) = 0	READ THE CURRENT CLOCK SETTING		:
;		RETURNS CX = HIGH PORTION OF COUNT	:
;			DX = LOW PORTION OF COUNT	:
;			AL = 0 IF TIMER HAS NOT PASSED	:
;			 24 HOURS SINCE LAST READ	:
;			   <>0 IF ON ANOTHER DAY	:
;   (AH) = 1	SET THE CURRENT CLOCK			:
;	CX = HIGH PORTION OF COUNT			:
;	DX = LOW PORTION OF COUNT			:
; NOTE: COUNTS OCCUR AT THE RATE OF			:
;	 1193180/65536 COUNTS/SEC			:
;	(OR ABOUT 18.2 PER SECOND -- SEE EQUATES BELOW) :
;--------------------------------------------------------
	TIMES	0FE6EH-($-$$) DB 0FFh
TIME_OF_DAY:
	STI				; INTERRUPTS BACK ON
	PUSH	DS			; SAVE SEGMENT
	CALL	DDS
	OR	AH,AH			; AH=0
	JZ	T2			; READ_TIME
	DEC	AH			; AH=1
	JZ	T3			; SET_TIME
T1:					; TOD_RETURN
	STI				; INTERRUPTS BACK ON
	POP	DS			; RECOVER SEGMENT
	IRET				; RETURN TO CALLER
T2:					; READ_TIME
	CLI				; NO TIMER INTERRUPTS WHILE READING
	MOV	AL,[BiosData.timerOfl]
	MOV	[BiosData.timerOfl],BYTE 0	; GET OVERFLOW, AND RESET THE FLAG
	MOV	CX,[BiosData.timerHigh]
	MOV	DX,[BiosData.timerLow]
	JMP	SHORT T1		; TOD_RETURN
T3:					; SET_TIME
	CLI				; NO INTERRUPTS WHILE WRITING
	MOV	[BiosData.timerLow],DX
	MOV	[BiosData.timerHigh],CX	; SET THE TIME
	MOV	[BiosData.timerOfl],BYTE 0	; RESET OVERFLOW
	JMP	SHORT T1		; TOD_RETURN

;--------------------------------------------------------
; THIS ROUTINE HANDLES THE TIMER INTERRUPT FROM 	:
;  CHANNEL 0 OF THE 8253 TIMER. INPUT FREQUENCY 	:
;  IS 1.19318 MHZ AND THE DIVISOR IS 65536, RESULTING	:
;  IN APPROX. 18.2 INTERRUPTS EVERY SECOND.		:
;							:
; THE INTERRUPT HANDLER MAINTAINS A COUNT OF INTERRUPTS :
;  SINCE POWER ON TIME, WHICH MAY BE USED TO ESTABLISH	:
;  TIME OF DAY. 					:
; THE INTERRUPT HANDLER ALSO DECREMENTS THE MOTOR	:
;  CONTROL COUNT OF THE DISKETTE, AND WHEN IT EXPIRES,	:
;  WILL TURN OFF THE DISKETTE MOTOR, AND RESET THE	:
;  MOTOR RUNNING FLAGS. 				:
; THE INTERRUPT HANDLER WILL ALSO INVOKE A USER ROUTINE :
;  THROUGH INTERRUPT 1CH AT EVERY TIME TICK.  THE USER	:
;  MUST CODE A ROUTINE AND PLACE THE CORRECT ADDRESS IN :
;  THE VECTOR TABLE.					:
;--------------------------------------------------------
	TIMES	0FEA5H-($-$$) DB 0FFh
TIMER_INT:
	STI				; INTERRUPTS BACK ON
	PUSH	DS
	PUSH	AX
	PUSH	DX			; SAVE MACHINE STATE
	CALL	DDS
	INC	WORD [BiosData.timerLow]; INCREMENT TIME
	JNZ	T4			; TEST_DAY
	INC	WORD [BiosData.timerHigh]	; INCREMENT HIGH WORD OF TIME
T4:					; TEST_DAY
	CMP	WORD [BiosData.timerHigh],BYTE 018H 	; TEST FOR COUNT EQUALLING 24 HOURS
	JNZ	T5			; DISKETTE_CTL
	CMP	WORD [BiosData.timerLow],0B0H
	JNZ	T5			; DISKETTE_CTL

;----- TIMER HAS GONE 24 HOURS

	SUB	AX,AX
	MOV	[BiosData.timerHigh],AX
	MOV	[BiosData.timerLow],AX
	MOV	[BiosData.timerOfl],BYTE 1

;----- TEST FOR DISKETTE TIME OUT

T5:					; DISKETTE_CTL
	DEC	BYTE [BiosData.motorCount]
	JNZ	T6			; RETURN IF COUNT NOT OUT
	AND	[BiosData.motorStatus],BYTE 0F0H; TURN OFF MOTOR RUNNING BITS
	MOV	AL,0CH
	MOV	DX,03F2H		; FDC_CTL_PORT
	OUT	DX,AL			; TURN OFF THE MOTOR
T6:					; TIMER_RET:
	INT	1CH			; TRANSFER CONTROL TO A USER ROUTINE
	MOV	AL,EOI
	OUT	020H,AL 		; END OF INTERRUPT TO 8259
	POP	DX
	POP	AX
	POP	DS			; RESET MACHINE STATE
	IRET				; RETURN FROM INTERRUPT

F3B:
	DB	'1801',13,10

;----------------------------------------------------------------
;	THESE ARE THE VECTORS WHICH ARE MOVED INTO		:
;	THE 8086 INTERRUPT AREA DURING POWER ON.		:
;	ONLY THE OFFSETS DISPLAYED HERE, CODE SEGMENT		:
;	WILL BE ADDED FOR ALL OF THEM, EXCEPT WHERE NOTED	:
;----------------------------------------------------------------
	TIMES	0FEF3H-($-$$) DB 0FFh
VECTOR_TABLE:				; VECTOR TABLE FOR MOVE TO INTERRUPTS
	DW	TIMER_INT		; INTERRUPT 8
	DW	KB_INT			; INTERRUPT 9
	DW	D_EOI			; INTERRUPT A
	DW	D_EOI			; INTERRUPT B
	DW	D_EOI			; INTERRUPT C
	DW	D_EOI			; INTERRUPT D
	DW	DISK_INT 		; INTERRUPT E
	DW	D_EOI			; INTERRUPT F
	DW	VIDEO_IO 		; INTERRUPT 10H
	DW	EQUIPMENT		; INTERRUPT 11H
	DW	MEMORY_SIZE_DET		; INTERRUPT 12H
	DW	DISKETTE_IO		; INTERRUPT 13H
	DW	RS232_IO 		; INTERRUPT 14H
	DW	CASSETTE_IO		; INTERRUPT 15H
	DW	KEYBOARD_IO		; INTERRUPT 16H
	DW	PRINTER_IO		; INTERRUPT 17H

	DW	00000H			; INTERRUPT 18H
;	DW	0F600H			;  MUST BE INSERTED INTO TABLE LATER

	DW	BOOT_STRAP		; INTERRUPT 19H
	DW	TIME_OF_DAY		; INTERRUPT 1AH -- TIME OF DAY
	DW	DUMMY_RETURN		; INTERRUPT 1BH -- KEYBOARD BREAK ADDR
	DW	DUMMY_RETURN		; INTERRUPT 1CH -- TIMER BREAK ADDR
	DW	VIDEO_PARMS		; INTERRUPT 1DH -- VIDEO PARAMETERS
	DW	DISK_BASE		; INTERRUPT 1EH -- DISK PARMS
	DW	0			; INTERRUPT 1FH -- POINTER TO VIDEO EXT

D2:
	DB	'PARITY CHECK 1',13,10
F1:
	DB	' 301',13,10
F2:
	DB	'131',13,10

DDS:
	PUSH	AX			; SAVE AX
	MOV	AX,DATA
	MOV	DS,AX			; SET DATA SEGMENT
	POP	AX			; RESTORE AX
	RET

;--------------------------------------------------------
;	TEMPORARY INTERRUPT SERVICE ROUTINE		:
;--------------------------------------------------------
	TIMES	0FF47H-($-$$) DB 0FFh
D11:
	MOV	AH,1
	PUSH	AX			; SAVE REG AX CONTENTS
	MOV	AL,0FFH 		; MASK ALL INTERRUPTS OFF
	OUT	INTA01,AL
	MOV	AL,EOI
	OUT	INTA00,AL
	POP	AX			; RESTORE REG AX CONTENTS
DUMMY_RETURN:				; NEED IRET FOR VECTOR TABLE
	IRET

;-- INT 5 ---------------------------------------------------------------
;	THIS LOGIC WILL BE INVOKED BY INTERRUPT 05H TO PRINT THE	:
;	SCREEN. THE CURSOR POSITION AT THE TIME THIS ROUTINE IS INVOKED :
;	WILL BE SAVED AND RESTORED UPON COMPLETION. THE ROUTINE IS	:
;	INTENDED TO RUN WITH INTERRUPTS ENABLED. IF A SUBSEQUENT	:
;	'PRINT SCREEN' KEY IS DEPRESSED DURING THE TIME THIS ROUTINE    :
;	IS PRINTING IT WILL BE IGNORED. 				:
;	ADDRESS 50:0 CONTAINS THE STATUS OF THE PRINT SCREEN:		:
;									:
;	50:0	=0	EITHER PRINT SCREEN HAS NOT BEEN CALLED 	:
;			OR UPON RETURN FROM A CALL THIS INDICATES	:
;			A SUCCESSFUL OPERATION. 			:
;		=1	PRINT SCREEN IS IN PROGRESS			:
;		=255	ERROR ENCOUNTERED DURING PRINTING		:
;------------------------------------------------------------------------
	TIMES	0FF54H-($-$$) DB 0FFh
PRINT_SCREEN:
	STI				; MUST RUN WITH INTERRUPTS ENABLED
	PUSH	DS			; MUST USE 50:0 FOR DATA AREA STORAGE
	PUSH	AX
	PUSH	BX
	PUSH	CX			; WILL USE THIS LATER FOR CURSOR LIMITS
	PUSH	DX			; WILL HOLD CURRENT CURSOR POSITION
	MOV	AX,XXDATA		; HEX 50
	MOV	DS,AX
	CMP	BYTE [STATUS_BYTE],1	; SEE IF PRINT ALREADY IN PROGRESS
	JZ	EXIT			; JUMP IF PRINT ALREADY IN PROGRESS
	MOV	BYTE [STATUS_BYTE],1	; INDICATE PRINT NOW IN PROGRESS
	MOV	AH,15			; WILL REQUEST THE CURRENT SCREEN MODE
	INT	10H			;	[AL]=MODE
					;	[AH]=NUMBER COLUMNS/LINE
					;	[BH]=VISUAL PAGE
;----------------------------------------------------------------
;	AT THIS POINT WE KNOW THE COLUMNS/LINE ARE IN		:
;	[AX] AND THE PAGE IF APPLICABLE IS IN [BH]. THE STACK	:
;	HAS DS,AX,BX,CX,DX PUSHED. [AL] HAS VIDEO MODE		:
;----------------------------------------------------------------
	MOV	CL,AH			; WILL MAKE USE OF [CX] REGISTER TO
	MOV	CH,25			; CONTROL ROW & COLUMNS
	CALL	CRLF			; CARRIAGE RETURN LINE FEED ROUTINE
	PUSH	CX			; SAVE SCREEN BOUNDS
	MOV	AH,3			; WILL NOW READ THE CURSOR.
	INT	10H			; AND PRESERVE THE POSITION
	POP	CX			; RECALL SCREEN BOUNDS
	PUSH	DX			; RECALL [BH]=VISUAL PAGE
	XOR	DX,DX			; WILL SET CURSOR POSITION TO [0,0]
;----------------------------------------------------------------
;	THE LOOP FROM PRI10 TO THE INSTRUCTION PRIOR TO PRI20	:
;	IS THE LOOP TO READ EACH CURSOR POSITION FROM THE	:
;	SCREEN AND PRINT.					:
;----------------------------------------------------------------
PRI10:
	MOV	AH,2			; TO INDICATE CURSOR SET REQUEST
	INT	10H			; NEW CURSOR POSITION ESTABLISHED
	MOV	AH,8			; TO INDICATE READ CHARACTER
	INT	10H			; CHARACTER NOW IN [AL]
	OR	AL,AL			; SEE IF VALID CHAR
	JNZ	PRI15			; JUMP IF VALID CHAR
	MOV	AL,' '                  ; MAKE A BLANK
PRI15:
	PUSH	DX			; SAVE CURSOR POSITION
	XOR	DX,DX			; INDICATE PRINTER 1
	XOR	AH,AH			; TO INDICATE PRINT CHAR IN [AL]
	INT	17H			; PRINT THE CHARACTER
	POP	DX			; RECALL CURSOR POSITION
	TEST	AH,25H			; TEST FOR PRINTER ERROR
	JNZ	ERR10			; JUMP IF ERROR DETECTED
	INC	DL			; ADVANCE TO NEXT COLUMN
	CMP	CL,DL			; SEE IF AT END OF LINE
	JNZ	PRI10			; IF NOT PROCEED
	XOR	DL,DL			; BACK TO COLUMN 0
	MOV	AH,DL			; [AH]=0
	PUSH	DX			; SAVE NEW CURSOR POSITION
	CALL	CRLF			; LINE FEED CARRIAGE RETURN
	POP	DX			; RECALL CURSOR POSITION
	INC	DH			; ADVANCE TO NEXT LINE
	CMP	CH,DH			; FINISHED?
	JNZ	PRI10			; IF NOT CONTINUE
PRI20:
	POP	DX			; RECALL CURSOR POSITION
	MOV	AH,2			; TO INDICATE CURSOR SET REQUEST
	INT	10H			; CURSOR POSITION RESTORED
	MOV	BYTE [STATUS_BYTE],0	; INDICATE FINISHED
	JMP	SHORT EXIT		; EXIT THE ROUTINE
ERR10:
	POP	DX			; GET CURSOR POSITION
	MOV	AH,2			; TO REQUEST CURSOR SET
	INT	10H			; CURSOR POSITION RESTORED
ERR20:
	MOV	BYTE [STATUS_BYTE],0FFH	; INDICATE ERROR
EXIT:
	POP	DX			; RESTORE ALL THE REGISTERS USED
	POP	CX
	POP	BX
	POP	AX
	POP	DS
	IRET

;------ CARRIAGE RETURN, LINE FEED SUBROUTINE

CRLF:
	XOR	DX,DX			; PRINTER 0
	XOR	AH,AH			; WILL NOW SEND INITIAL LF,CR
					;  TO PRINTER
	MOV	AL,12Q			; LF
	INT	17H			; SEND THE LINE FEED
	XOR	AH,AH			; NOW FOR THE CR
	MOV	AL,15Q			; CR
	INT	17H			; SEND THE CARRIAGE RETURN
	RET

D1:
	DB	'PARITY CHECK 2',13,10
F3:
	DB	'601',13,10

;----------------------------------------
;	POWER ON RESET VECTOR		:
;----------------------------------------
;VECTOR	SEGMENT AT 0FFFFH

;----- POWER ON RESET
	TIMES	0FFF0H-($-$$) DB 0FFh
	JMP	0F000H:RESET

	DB	'10/27/82'              ; RELEASE MARKER
	TIMES	2 DB 0FFh
