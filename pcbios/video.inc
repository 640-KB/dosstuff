%ifndef __VIDEO_INC__
%define __VIDEO_INC__

;--- INT 10 -------------------------------------------------------------
; VIDEO_IO								:
;	THESE ROUTINES PROVIDE THE CRT INTERFACE			:
;	THE FOLLOWING FUNCTIONS ARE PROVIDED:				:
;	(AH)=0	SET MODE (AL) CONTAINS MODE VALUE			:
;		(AL)=0 40X25 BW (POWER ON DEFAULT)			:
;		(AL)=1 40X25 COLOR					:
;		(AL)=2 80X25 BW 					:
;		(AL)=3 80X25 COLOR					:
;		GRAPHICS MODES						:
;		(AL)=4 320X200 COLOR					:
;		(AL)=5 320X200 BW					:
;		(AL)=6 640X200 BW					:
;		CRT MODE=7 80X25 B&W CARD (USED INTERNAL TO VIDEO ONLY) :
;		*** NOTE BW MODES OPERATE SAME AS COLOR MODES, BUT	:
;			 COLOR BURST IS NOT ENABLED			:
;	(AH)=1	SET CURSOR TYPE 					:
;		(CH) = BITS 4-0 = START LINE FOR CURSOR 		:
;		       ** HARDWARE WILL ALWAYS CAUSE BLINK		:
;		       ** SETTING BIT 5 OR 6 WILL CAUSE ERRATIC 	:
;			  BLINKING OR NO CURSOR AT ALL			:
;		(CL) = BITS 4-0 = END LINE FOR CURSOR			:
;	(AH)=2	SET CURSOR POSITION					:
;		(DH,DL) = ROW,COLUMN  (0,0) IS UPPER LEFT		:
;		(DH) = PAGE NUMBER (MUST BE 0 FOR GRAPHICS MODES)	:
;	(AH)=3	READ CURSOR POSITION					:
;		(BH) = PAGE NUMBER (MUST BE 0 FOR GRAPHICS MODES)	:
;		ON EXIT (DH,DL) = ROW,COLUMN OF CURRENT CURSOR		:
;			(CH,CL) = CURSOR MODE CURRENTLY SET		:
;	(AH)=4	READ LIGHT PEN POSITION 				:
;		ON EXIT:						:
;		(AH) = 0 -- LIGHT PEN SWITCH NOT DOWN/NOT TRIGGERED	:
;		(AH) = 1 -- VALID LIGHT PEN VALUE IN REGISTERS		:
;			(DH,DL) = ROW, COLUMN OF CHARACTER LP POSN	:
;			(CH) = RASTER LINE (0-199)			:
;			(BX) = PIXEL COLUMN (0-319,639) 		:
;	(AH)=5	SELECT ACTIVE DISPLAY PAGE (VALID ONLY FOR ALPHA MODES) :
;		(AL)=NEW PAGE VAL (0-7 FOR MODES 0&1, 0-3 FOR MODES 2&3):
;	(AH)=6	SCROLL ACTIVE PAGE UP					:
;		(AL) = NUMBER OF LINES, INPUT LINES BLANKED AT BOTTOM	:
;		       OF WINDOW					:
;			AL = 0 MEANS BLANK ENTIRE WINDOW		:
;		(CH,CL) = ROW,COLUMN OF UPPER LEFT CORNER OF SCROLL	:
;		(DH,DL) = ROW,COLUMN OF LOWER RIGHT CORNER OF SCROLL	:
;		(BH) = ATTRIBUTE TO BE USED ON BLANK LINE		:
;	(AH)=7	SCROLL ACTIVE PAGE DOWN 				:
;		(AL) = NUMBER OF LINES, INPUT LINES BLANKED AT TOP	:
;		       OF WINDOW					:
;			AL = 0 MEANS BLANK ENTIRE WINDOW		:
;		(CH,CL) = ROW,COLUMN OF UPPER LEFT CORNER OF SCROLL	:
;		(DH,DL) = ROW,COLUMN OF LOWER RIGHT CORNER OF SCROLL	:
;		(BH) = ATTRIBUTE TO BE USED ON BLANK LINE		:
;									:
;	CHARACTER HANDLING ROUTINES					:
;									:
;	(AH) = 8 READ ATTRIBUTE/CHARACTER AT CURRENT CURSOR POSITION	:
;		(BH) = DISPLAY PAGE (VALID FOR ALPHA MODES ONLY)	:
;		ON EXIT:						:
;		(AL) = CHAR READ					:
;		(AH) = ATTRIBUTE OF CHARACTER READ (ALPHA MODES ONLY)	:
;	(AH) = 9 WRITE ATTRIBUTE/CHARACTER AT CURRENT CURSOR POSITION	:
;		(BH) = DISPLAY PAGE (VALID FOR ALPHA MODES ONLY)	:
;		(CX) = COUNT OF CHARACTERS TO WRITE			:
;		(AL) = CHAR TO WRITE					:
;		(BL) = ATTRIBUTE OF CHARACTER (ALPHA)/COLOR OF CHAR	:
;		       (GRAPHICS)					:
;			SEE NOTE ON WRITE DOT FOR BIT 7 OF BL = 1.	:
;	(AH) = 10 WRITE CHARACTER ONLY AT CURRENT CURSOR POSITION	:
;		(BH) = DISPLAY PAGE (VALID FOR ALPHA MODES ONLY)	:
;		(CX) = COUNT OF CHARACTERS TO WRITE			:
;		(AL) = CHAR TO WRITE					:
;	FOR READ/WRITE CHARACTER INTERFACE WHILE IN GRAPHICS MODE, THE	:
;		CHARACTERS ARE FORMED FROM A CHARACTER GENERATOR IMAGE	:
;		MAINTAINED IN THE SYSTEM ROM.  ONLY THE 1ST 128 CHARS	:
;		ARE CONTAINED THERE.  TO READ/WRITE THE SECOND 128	:
;		CHARS. THE USER MUST INITIALIZE THE POINTER AT		:
;		INTERRUPT 1FH (LOCATION 0007CH) TO POINT TO THE 1K BYTE :
;		TABLE CONTAINING THE CODE POINTS FOR THE SECOND 	:
;		128 CHARS (128-255).					:
;	FOR WRITE CHARACTER INTERFACE IN GRAPHICS MODE, THE REPLICATION :
;		FACTOR CONTAINED IN (CX) ON ENTRY WILL PRODUCE VALID	:
;		RESULTS ONLY FOR CHARACTERS CONTAINED ON THE SAME ROW.	:
;		CONTINUATION TO SUCCEEDING LINES WILL NOT PRODUCE	:
;		CORRECTLY.						:
;									:
;	GRAPHICS INTERFACE						:
;	(AH) = 11 SET COLOR PALETTE					:
;		(BH) = PALETTE COLOR ID BEING SET (0-127)		:
;		(BL) = COLOR VALUE TO BE USED WITH THAT COLOR ID	:
;		   NOTE: FOR THE CURRENT COLOR CARD, THIS ENTRY POINT	:
;			 HAS MEANING ONLY FOR 320X200 GRAPHICS. 	:
;			COLOR ID = 0 SELECTS THE BACKGROUND COLOR (0-15):
;			COLOR ID = 1 SELECTS THE PALETTE TO BE USED:	:
;				0 = GREEN(1)/RED(2)/YELLOW(3)		:
;				1 = CYAN(1)/MAGENTA(2)/WHITE(3) 	:
;			IN 40X25 OR 80X25 ALPHA MODES, THE VALUE SET	:
;				FOR PALETTE COLOR 0 INDICATES THE	:
;				BORDER COLOR TO BE USED (VALUES 0-31,	:
;				WHERE 16-31 SELECT THE HIGH INTENSITY	:
;				BACKGROUND SET. 			:
;	(AH) = 12 WRITE DOT						:
;		(DX) = ROW NUMBER					:
;		(CX) = COLUMN NUMBER					:
;		(AL) = COLOR VALUE					:
;			IF BIT 7 OF AL = 1, THEN THE COLOR VALUE IS	:
;			EXCLUSIVE OR'D WITH THE CURRENT CONTENTS OF     :
;			THE DOT 					:
;	(AH) = 13 READ DOT						:
;		(DX) = ROW NUMBER					:
;		(CX) = COLUMN NUMBER					:
;		(AL) RETURNS THE DOT READ				:
;									:
; ASCII TELETYPE ROUTINE FOR OUTPUT					:
;									:
;	(AH) = 14 WRITE TELETYPE TO ACTIVE PAGE 			:
;		(AL) = CHAR TO WRITE					:
;		(BL) = FOREGROUND COLOR IN GRAPHICS MODE		:
;		NOTE -- SCREEN WIDTH IS CONTROLLED BY PREVIOUS MODE SET :
;									:
;	(AH) = 15 CURRENT VIDEO STATE					:
;		RETURNS THE CURRENT VIDEO STATE 			:
;		(AL) = MODE CURRENTLY SET (SEE AH=0 FOR EXPLANATION)	:
;		(AH) = NUMBER OF CHARACTER COLUMNS ON SCREEN		:
;		(BH) = CURRENT ACTIVE DISPLAY PAGE			:
;									:
;	CS,SS,DS,ES,BX,CX,DX PRESERVED DURING CALL			:
;	ALL OTHERS DESTROYED						:
;------------------------------------------------------------------------
	TIMES	0F045H-($-$$) DB 0FFh
M1:					; TABLE OF ROUTINES WITHIN VIDEO I/O
	DW	SET_MODE
	DW	SET_CTYPE
	DW	SET_CPOS
	DW	READ_CURSOR
	DW	READ_LPEN
	DW	ACT_DISP_PAGE
	DW	SCROLL_UP
	DW	SCROLL_DOWN
	DW	READ_AC_CURRENT
	DW	WRITE_AC_CURRENT
	DW	WRITE_C_CURRENT
	DW	SET_COLOR
	DW	WRITE_DOT
	DW	READ_DOT
	DW	WRITE_TTY
	DW	VIDEO_STATE
M1L	EQU	$-M1

	TIMES	0F065H-($-$$) DB 0FFh
VIDEO_IO:
	STI				; INTERRUPTS BACK ON
	CLD				; SET DIRECTION FORWARD
	PUSH	ES
	PUSH	DS			; SAVE SEGMENT REGISTERS
	PUSH	DX
	PUSH	CX
	PUSH	BX
	PUSH	SI
	PUSH	DI
	PUSH	AX			; SAVE AX VALUE
	MOV	AL,AH			; GET INTO LOW BYTE
	XOR	AH,AH			; ZERO TO HIGH BYTE
	SAL	AX,1			; *2 FOR TABLE LOOKUP
	MOV	SI,AX			; PUT INTO SI FOR BRANCH
	CMP	AX,M1L			; TEST FOR WITHIN RANGE
	JB	M2			; BRANCH AROUND BRANCH
	POP	AX			; THROW AWAY THE PARAMETER
	JMP	VIDEO_RETURN		; DO NOTHING IF NOT IN RANGE
M2:
	CALL	DDS
	MOV	AX,0B800H		; SEGMENT FOR COLOR CARD
	MOV	DI,[BiosData.equipFlag]	; GET EQUIPMENT SETTING
	AND	DI,30H			; ISOLATE CRT SWITCHES
	CMP	DI,BYTE 30H		; IS SETTING FOR BW CARD?
	JNE	M3
	MOV	AH,0B0H 		; SEGMENT FOR BW CARD
M3:
	MOV	ES,AX			; SET UP TO POINT AT VIDEO RAM AREAS
	POP	AX			; RECOVER VALUE
	MOV	AH,[BiosData.crtMode]	; GET CURRENT MODE INTO AH
	CS JMP	WORD [SI+M1]
;--------------------------------------------------------
; SET_MODE						:
;	THIS ROUTINE INITIALIZES THE ATTACHMENT TO	:
;	THE SELECTED MODE.  THE SCREEN IS BLANKED.	:
; INPUT 						:
;	(AL) = MODE SELECTED (RANGE 0-9)		:
; OUTPUT						:
;	NONE						:
;--------------------------------------------------------

;----- TABLES FOR USE IN SETTING OF MODE

	TIMES	0F0A4H-($-$$) DB 0FFh
VIDEO_PARMS:
;----- INIT_TABLE
	DB	38H,28H,2DH,0AH,1FH,6,19H	; SET UP FOR 40X25
	DB	1CH,2,7,6,7
	DB	0,0,0,0
M4	EQU	$-VIDEO_PARMS

	DB	71H,50H,5AH,0AH,1FH,6,19H	; SET UP FOR 80X25
	DB	1CH,2,7,6,7
	DB	0,0,0,0

	DB	38H,28H,2DH,0AH,7FH,6,64H	; SET UP FOR GRAPHICS
	DB	70H,2,1,6,7
	DB	0,0,0,0

	DB	61H,50H,52H,0FH,19H,6,19H	; SET UP FOR 80X25 B&W CARD
	DB	19H,2,0DH,0BH,0CH
	DB	0,0,0,0

M5:					; TABLE OF REGEN LENGTHS
	DW	2048			; 40X25
	DW	4096			; 80X25
	DW	16384			; GRAPHICS
	DW	16384

;----- COLUMNS

M6:
	DB	40,40,80,80,40,40,80,80

;----- C_REG_TAB

M7:					; TABLE OF MODE SETS
	DB	2CH,28H,2DH,29H,2AH,2EH,1EH,29H

SET_MODE:
	MOV	DX,03D4H		; ADDRESS OF COLOR CARD
	MOV	BL,0			; MODE SET FOR COLOR CARD
	CMP	DI,BYTE 30H		; IS BW CARD INSTALLED
	JNE	M8			; OK WITH COLOR
	MOV	AL,7			; INDICATE BW CARD MODE
	MOV	DL,0B4H 		; ADDRESS OF BW CARD
	INC	BL			; MODE SET FOR BW CARD
M8:
	MOV	AH,AL			; SAVE MODE IN AH
	MOV	[BiosData.crtMode],AL	; SAVE IN GLOBAL VARIABLE
	MOV	[BiosData.addr6845],DX	; SAVE ADDRESS OF BASE
	PUSH	DS			; SAVE POINTER TO DATA SEGMENT
	PUSH	AX			; SAVE MODE
	PUSH	DX			; SAVE OUTPUT PORT VALUE
	ADD	DX,BYTE 4		; POINT TO CONTROL REGISTER
	MOV	AL,BL			; GET MODE SET FOR CARD
	OUT	DX,AL			; RESET VIDEO
	POP	DX			; BACK TO BASE REGISTER
	SUB	AX,AX			; SET UP FOR ABS0 SEGMENT
	MOV	DS,AX			; ESTABLISH VECTOR TABLE ADDRESSING
	LDS	BX,[PARM_PTR]		; GET POINTER TO VIDEO PARMS
	POP	AX			; RECOVER PARMS
	MOV	CX,M4			; LENGTH OF EACH ROW OF TABLE
	CMP	AH,2			; DETERMINE WHICH ONE TO USE
	JC	M9			; MODE IS 0 OR 1
	ADD	BX,CX			; MOVE TO NEXT ROW OF INIT_TABLE
	CMP	AH,4
	JC	M9			; MODE IS 2 OR 3
	ADD	BX,CX			; MOVE TO GRAPHICS ROW OF INIT_TABLE
	CMP	AH,7
	JC	M9			; MODE IS 4,5, OR 6
	ADD	BX,CX			; MOVE TO BW CARD ROW OF INIT_TABLE

;----- BX POINTS TO CORRECT ROW OF INITIALIZATION TABLE

M9:					; OUT_INIT
	PUSH	AX			; SAVE MODE IN AH
	XOR	AH,AH			; AH WILL SERVE AS REGISTER
					;  NUMBER DURING LOOP

;----- LOOP THROUGH TABLE, OUTPUTTING REG ADDRESS, THEN VALUE FROM TABLE

M10:					; INIT LOOP
	MOV	AL,AH			; GET 6845 REGISTER NUMBER
	OUT	DX,AL
	INC	DX			; POINT TO DATA PORT
	INC	AH			; NEXT REGISTER VALUE
	MOV	AL,[BX] 		; GET TABLE VALUE
	OUT	DX,AL			; OUT TO CHIP
	INC	BX			; NEXT IN TABLE
	DEC	DX			; BACK TO POINTER REGISTER
	LOOP	M10			; DO THE WHOLE TABLE
	POP	AX			; GET MODE BACK
	POP	DS			; RECOVER SEGMENT VALUE

;----- FILL REGEN AREA WITH BLANK

	XOR	DI,DI			; SET UP POINTER FOR REGEN
	MOV	[BiosData.crtStart],DI	; START ADDRESS SAVED IN GLOBAL
	MOV	[BiosData.activePage],BYTE 0	; SET PAGE VALUE
	MOV	CX,8192 		; NUMBER OF WORDS IN COLOR CARD
	CMP	AH,4			; TEST FOR GRAPHICS
	JC	M12			; NO_GRAPHICS_INIT
	CMP	AH,7			; TEST FOR BW CARD
	JE	M11			; BW_CARD_INIT
	XOR	AX,AX			; FILL FOR GRAPHICS MODE
	JMP	SHORT M13		; CLEAR_BUFFER
M11:					; BW_CARD_INIT
	MOV	CH,08H			; BUFFER SIZE ON BW CARD
M12:					; NO_GRAPHICS_INIT
	MOV	AX,' '+7*256            ; FILL CHAR FOR ALPHA
M13:					; CLEAR BUFFER
	REP	STOSW			; FILL THE REGEN BUFFER WITH BLANKS

;----- ENABLE VIDEO AND CORRECT PORT SETTING

	MOV	[BiosData.cursorMode],WORD 607H	; SET CURRENT CURSOR MODE
	MOV	AL,[BiosData.crtMode]	; GET THE MODE
	XOR	AH,AH			;  INTO AX REGISTER
	MOV	SI,AX			; TABLE POINTER, INDEXED BY MODE
	MOV	DX,[BiosData.addr6845]	; PREPARE TO OUTPUT TO
					;  VIDEO ENABLE PORT
	ADD	DX,BYTE 4
	CS MOV	AL,[SI+M7]
	OUT	DX,AL			; SET VIDEO ENABLE PORT
	MOV	[BiosData.crtModeSet],AL; SAVE THAT VALUE

;----- DETERMINE NUMBER OF COLUMNS, BOTH FOR ENTIRE DISPLAY
;----- AND THE NUMBER TO BE USED FOR TTY INTERFACE

	CS MOV	AL,[SI + M6]
	XOR	AH,AH
	MOV	[BiosData.crtCols],AX	; NUMBER OF COLUMNS IN THIS SCREEN

;----- SET CURSOR POSITIONS

	AND	SI,0EH			; WORD OFFSET INTO CLEAR LENGTH TABLE
	CS MOV	CX,[SI+M5]		; LENGTH TO CLEAR
	MOV	[BiosData.crtLen],CX	; SAVE LENGTH OF CRT -- NOT USED FOR BW
	MOV	CX,8			; CLEAR ALL CURSOR POSITIONS
	MOV	DI,BiosData.cursorPosn
	PUSH	DS			; ESTABLISH SEGMENT
	POP	ES			;   ADDRESSING
	XOR	AX,AX
	REP	STOSW			; FILL WITH ZEROES

;----- SET UP OVERSCAN REGISTER

	INC	DX			; SET OVERSCAN PORT TO A DEFAULT
	MOV	AL,30H			; VALUE OF 30H FOR ALL MODES
					;  EXCEPT 640X200
	CMP	[BiosData.crtMode],BYTE 6	; SEE IF THE MODE IS 640X200 BW
	JNZ	M14			; IF IT ISNT 640X200, THEN GOTO REGULAR
	MOV	AL,3FH			; IF IT IS 640X200, THEN PUT IN 3FH
M14:
	OUT	DX,AL			; OUTPUT THE CORRECT VALUE TO 3D9 PORT
	MOV	[BiosData.crtPalette],AL; SAVE THE VALUE FOR FUTURE USE

;----- NORMAL RETURN FROM ALL VIDEO RETURNS

VIDEO_RETURN:
	POP	DI
	POP	SI
	POP	BX
M15:					; VIDEO_RETURN_C
	POP	CX
	POP	DX
	POP	DS
	POP	ES			; RECOVER SEGMENTS
	IRET				; ALL DONE
;----------------------------------------------------------------
; SET_CTYPE							:
;	THIS ROUTINE SETS THE CURSOR VALUE			:
; INPUT 							:
;	(CX) HAS CURSOR VALUE CH-START LINE, CL-STOP LINE	:
; OUTPUT							:
;	NONE							:
;----------------------------------------------------------------
SET_CTYPE:
	MOV	AH,10			; 6845 REGISTER FOR CURSOR SET
	MOV	[BiosData.cursorMode],CX; SAVE IN DATA AREA
	CALL	M16			; OUTPUT CX REG
	JMP	SHORT VIDEO_RETURN

;----- THIS ROUTINE OUTPUTS THE CX REGISTER TO THE 6845 REGS NAMED IN AH

M16:
	MOV	DX,[BiosData.addr6845]	; ADDRESS REGISTER
	MOV	AL,AH			; GET VALUE
	OUT	DX,AL			; REGISTER SET
	INC	DX			; DATA REGISTER
	MOV	AL,CH			; DATA
	OUT	DX,AL
	DEC	DX
	MOV	AL,AH
	INC	AL			; POINT TO OTHER DATA REGISTER
	OUT	DX,AL			; SET FOR SECOND REGISTER
	INC	DX
	MOV	AL,CL			; SECOND DATA VALUE
	OUT	DX,AL
	RET				; ALL DONE
;------------------------------------------------
; SET_CPOS					:
;	THIS ROUTINE SETS THE CURRENT CURSOR	:
;	POSITION TO THE NEW X-Y VALUES PASSED	:
; INPUT 					:
;	DX - ROW, COLUMN OF NEW CURSOR		:
;	BH - DISPLAY PAGE OF CURSOR		:
; OUTPUT					:
;	CURSOR IS SET AT 6845 IF DISPLAY PAGE	:
;	IS CURRENT DISPLAY			:
;------------------------------------------------
SET_CPOS:
	MOV	CL,BH
	XOR	CH,CH			; ESTABLISH LOOP COUNT
	SAL	CX,1			; WORD OFFSET
	MOV	SI,CX			; USE INDEX REGISTER
	MOV	[SI+BiosData.cursorPosn],DX	; SAVE THE POINTER
	CMP	[BiosData.activePage],BH
	JNZ	M17			; SET_CPOS_RETURN
	MOV	AX,DX			; GET ROW/COLUMN TO AX
	CALL	M18			; CURSOR_SET
M17:					; SET_CPOS_RETURN
	JMP	SHORT VIDEO_RETURN

;----- SET CURSOR POSITION, AX HAS ROW/COLUMN FOR CURSOR

M18:
	CALL	POSITION		; DETERMINE LOCATION IN REGEN BUFFER
	MOV	CX,AX
	ADD	CX,[BiosData.crtStart]	; ADD IN THE START ADDR FOR THIS PAGE
	SAR	CX,1			; DIVIDE BY 2 FOR CHAR ONLY COUNT
	MOV	AH,14			; REGISTER NUMBER FOR CURSOR
	CALL	M16			; OUTPUT THE VALUE TO THE 6845
	RET
;----------------------------------------------------------------
; ACT_DISP_PAGE 						:
;	THIS ROUTINE SETS THE ACTIVE DISPLAY PAGE, ALLOWING THE :
;	FULL USE OF THE RAM SET ASIDE FOR THE VIDEO ATTACHMENT	:
; INPUT 							:
;	AL HAS THE NEW ACTIVE DISPLAY PAGE			:
; OUTPUT							:
;	THE 6845 IS RESET TO DISPLAY THAT PAGE			:
;----------------------------------------------------------------
ACT_DISP_PAGE:
	MOV	[BiosData.activePage],AL; SAVE ACTIVE PAGE VALUE
	MOV	CX,[BiosData.crtLen]	; GET SAVED LENGTH OF REGEN BUFFER
	CBW				; CONVERT AL TO WORD
	PUSH	AX			; SAVE PAGE VALUE
	MUL	CX			; DISPLAY PAGE TIMES REGEN LENGTH
	MOV	[BiosData.crtStart],AX	; SAVE START ADDRESS FOR
					;  LATER REQUIREMENTS
	MOV	CX,AX			; START ADDRESS TO CX
	SAR	CX,1			; DIVIDE BY 2 FOR 6845 HANDLING
	MOV	AH,12			; 6845 REGISTER FOR START ADDRESS
	CALL	M16
	POP	BX			; RECOVER PAGE VALUE
	SAL	BX,1			; *2 FOR WORD OFFSET
	MOV	AX,[BX+BiosData.cursorPosn]	; GET CURSOR FOR THIS PAGE
	CALL	M18			; SET THE CURSOR POSITION
	JMP	SHORT VIDEO_RETURN
;----------------------------------------------------------------
; READ_CURSOR							:
;	THIS ROUTINE READS THE CURRENT CURSOR VALUE FROM THE	:
;	6845, FORMATS IT, AND SENDS IT BACK TO THE CALLER	:
; INPUT 							:
;	BH - PAGE OF CURSOR					:
; OUTPUT							:
;	DX - ROW, COLUMN OF THE CURRENT CURSOR POSITION 	:
;	CX - CURRENT CURSOR MODE				:
;----------------------------------------------------------------
READ_CURSOR:
	MOV	BL,BH
	XOR	BH,BH
	SAL	BX,1			; WORD OFFSET
	MOV	DX,[BX+BiosData.cursorPosn]
	MOV	CX,[BiosData.cursorMode]
	POP	DI
	POP	SI
	POP	BX
	POP	AX			; DISCARD SAVED CX AND DX
	POP	AX
	POP	DS
	POP	ES
	IRET
;------------------------------------------------------------------------
; SET_COLOR								:
;	THIS ROUTINE WILL ESTABLISH THE BACKGROUND COLOR, THE OVERSCAN	:
;	COLOR, AND THE FOREGROUND COLOR SET FOR MEDIUM RESOLUTION	:
;	GRAPHICS							:
; INPUT 								:
;	(BH) HAS COLOR ID						:
;		IF BH=0, THE BACKGROUND COLOR VALUE IS SET		:
;			FROM THE LOW BITS OF BL (0-31)			:
;		IF BH=1, THE PALETTE SELECTION IS MADE			:
;			BASED ON THE LOW BIT OF BL:			:
;				0=GREEN, RED, YELLOW FOR COLORS 1,2,3	:
;				1=BLUE, CYAN, MAGENTA FOR COLORS 1,2,3	:
;	(BL) HAS THE COLOR VALUE TO BE USED				:
; OUTPUT								:
;	THE COLOR SELECTION IS UPDATED					:
;------------------------------------------------------------------------
SET_COLOR:
	MOV	DX,[BiosData.addr6845]	; I/O PORT FOR PALETTE
	ADD	DX,BYTE 5		; OVERSCAN PORT
	MOV	AL,[BiosData.crtPalette]; GET THE CURRENT PALETTE VALUE
	OR	BH,BH			; IS THIS COLOR 0?
	JNZ	M20			; OUTPUT COLOR 1

;----- HANDLE COLOR 0 BY SETTING THE BACKGROUND COLOR

	AND	AL,0E0H 		; TURN OFF LOW 5 BITS OF CURRENT
	AND	BL,01FH 		; TURN OFF HIGH 3 BITS OF INPUT VALUE
	OR	AL,BL			; PUT VALUE INTO REGISTER
M19:					; OUTPUT THE PALETTE
	OUT	DX,AL			; OUTPUT COLOR SELECTION TO 3D9 PORT
	MOV	[BiosData.crtPalette],AL; SAVE THE COLOR VALUE
	JMP	VIDEO_RETURN

;----- HANDLE COLOR 1 BY SELECTING THE PALETTE TO BE USED

M20:
	AND	AL,0DFH 		; TURN OFF PALETTE SELECT BIT
	SHR	BL,1			; TEST THE LOW ORDER BIT OF BL
	JNC	M19			; ALREADY DONE
	OR	AL,20H			; TURN ON PALETTE SELECT BIT
	JMP	SHORT M19		; GO DO IT
;------------------------------------------------
; VIDEO STATE					:
;  RETURNS THE CURRENT VIDEO STATE IN AX	:
;  AH = NUMBER OF COLUMNS ON THE SCREEN 	:
;  AL = CURRENT VIDEO MODE			:
;  BH = CURRENT ACTIVE PAGE			:
;------------------------------------------------
VIDEO_STATE:
	MOV	AH,[BiosData.crtCols]	; GET NUMBER OF COLUMNS
	MOV	AL,[BiosData.crtMode]	; CURRENT MODE
	MOV	BH,[BiosData.activePage]; GET CURRENT ACTIVE PAGE
	POP	DI			; RECOVER REGISTERS
	POP	SI
	POP	CX			; DISCARD SAVED BX
	JMP	M15			; RETURN TO CALLER
;--------------------------------------------------------
; POSITION						:
;	THIS SERVICE ROUTINE CALCULATES THE REGEN	:
;	BUFFER ADDRESS OF A CHARACTER IN THE ALPHA MODE :
; INPUT 						:
;	AX = ROW, COLUMN POSITION			:
; OUTPUT						:
;	AX = OFFSET OF CHAR POSITION IN REGEN BUFFER	:
;--------------------------------------------------------
POSITION:
	PUSH	BX			; SAVE REGISTER
	MOV	BX,AX
	MOV	AL,AH			; ROWS TO AL
	MUL	BYTE [BiosData.crtCols]	; DETERMINE BYTES TO ROW
	XOR	BH,BH
	ADD	AX,BX			; ADD IN COLUMN VALUE
	SAL	AX,1			; * 2 FOR ATTRIBUTE BYTES
	POP	BX
	RET
;--------------------------------------------------------
; SCROLL_UP						:
;	THIS ROUTINE MOVES A BLOCK OF CHARACTERS UP	:
;	ON THE SCREEN					:
; INPUT 						:
;	(AH) = CURRENT CRT MODE 			:
;	(AL) = NUMBER OF ROWS TO SCROLL 		:
;	(CX) = ROW/COLUMN OF UPPER LEFT CORNER		:
;	(DX) = ROW/COLUMN OF LOWER RIGHT CORNER 	:
;	(BH) = ATTRIBUTE TO BE USED ON BLANKED LINE	:
;	(DS) = DATA SEGMENT				:
;	(ES) = REGEN BUFFER SEGMENT			:
; OUTPUT						:
;	NONE -- THE REGEN BUFFER IS MODIFIED		:
;--------------------------------------------------------
SCROLL_UP:
	MOV	BL,AL			; SAVE LINE COUNT IN BL
	CMP	AH,4			; TEST FOR GRAPHICS MODE
	JC	N1			; HANDLE SEPARATELY
	CMP	AH,7			; TEST FOR BW CARD
	JE	N1
	JMP	GRAPHICS_UP
N1:					; UP_CONTINUE
	PUSH	BX			; SAVE FILL ATTRIBUTE IN BH
	MOV	AX,CX			; UPPER LEFT POSITION
	CALL	SCROLL_POSITION 	; DO SETUP FOR SCROLL
	JZ	N7			; BLANK_FIELD
	ADD	SI,AX			; FROM ADDRESS
	MOV	AH,DH			; # ROWS IN BLOCK
	SUB	AH,BL			; # ROWS TO BE MOVED
N2:					; ROW_LOOP
	CALL	N10			; MOVE ONE ROW
	ADD	SI,BP
	ADD	DI,BP			; POINT TO NEXT LINE IN BLOCK
	DEC	AH			; COUNT OF LINES TO MOVE
	JNZ	N2			; ROW_LOOP
N3:					; CLEAR_ENTRY
	POP	AX			; RECOVER ATTRIBUTE IN AH
	MOV	AL,' '                  ; FILL WITH BLANKS
N4:					; CLEAR_LOOP
	CALL	N11			; CLEAR THE ROW
	ADD	DI,BP			; POINT TO NEXT LINE
	DEC	BL			; COUNTER OF LINES TO SCROLL
	JNZ	N4			; CLEAR_LOOP
N5:					; SCROLL_END
	CALL	DDS
	CMP	[BiosData.crtMode],BYTE 7	; IS THIS THE BLACK AND WHITE CARD
	JE	N6			; IF SO, SKIP THE MODE RESET
	MOV	AL,[BiosData.crtModeSet]; GET THE VALUE OF THE MODE SET
	MOV	DX,03D8H		; ALWAYS SET COLOR CARD PORT
	OUT	DX,AL
N6:					; VIDEO_RET_HERE
	JMP	VIDEO_RETURN
N7:					; BLANK_FIELD
	MOV	BL,DH			; GET ROW COUNT
	JMP	SHORT N3		; GO CLEAR THAT AREA

;----- HANDLE COMMON SCROLL SET UP HERE

SCROLL_POSITION:
	CMP	[BiosData.crtMode],BYTE 2	; TEST FOR SPECIAL CASE HERE
	JB	N9			; HAVE TO HANDLE 80X25 SEPARATELY
	CMP	[BiosData.crtMode],BYTE 3
	JA	N9

;----- 80X25 COLOR CARD SCROLL

	PUSH	DX
	MOV	DX,3DAH 		; GUARANTEED TO BE COLOR CARD HERE
	PUSH	AX
N8:					; WAIT_DISP_ENABLE
	IN	AL,DX			; GET PORT
	TEST	AL,8			; WAIT FOR VERTICAL RETRACE
	JZ	N8			; WAIT_DISP_ENABLE
	MOV	AL,25H
	MOV	DL,0D8H 		; DX=3D8
	OUT	DX,AL			; TURN OFF VIDEO
	POP	AX			; DURING VERTICAL RETRACE
	POP	DX
N9:
	CALL	POSITION		; CONVERT TO REGEN POINTER
	ADD	AX,[BiosData.crtStart]	; OFFSET OF ACTIVE PAGE
	MOV	DI,AX			; TO ADDRESS FOR SCROLL
	MOV	SI,AX			; FROM ADDRESS FOR SCROLL
	SUB	DX,CX			; DX = #ROWS, #COLS IN BLOCK
	INC	DH
	INC	DL			; INCREMENT FOR 0 ORIGIN
	XOR	CH,CH			; SET HIGH BYTE OF COUNT TO ZERO
	MOV	BP,[BiosData.crtCols]	; GET NUMBER OF COLUMNS IN DISPLAY
	ADD	BP,BP			; TIMES 2 FOR ATTRIBUTE BYTE
	MOV	AL,BL			; GET LINE COUNT
	MUL	BYTE [BiosData.crtCols]	; DETERMINE OFFSET TO FROM ADDRESS
	ADD	AX,AX			; *2 FOR ATTRIBUTE BYTE
	PUSH	ES			; ESTABLISH ADDRESSING TO REGEN BUFFER
	POP	DS			;  FOR BOTH POINTERS
	CMP	BL,0			; 0 SCROLL MEANS BLANK FIELD
	RET				; RETURN WITH FLAGS SET

;----- MOVE_ROW

N10:
	MOV	CL,DL			; GET # OF COLS TO MOVE
	PUSH	SI
	PUSH	DI			; SAVE START ADDRESS
	REP	MOVSW			; MOVE THAT LINE ON SCREEN
	POP	DI
	POP	SI			; RECOVER ADDRESSES
	RET

;----- CLEAR_ROW

N11:
	MOV	CL,DL			; GET # COLUMNS TO CLEAR
	PUSH	DI
	REP	STOSW			; STORE THE FILL CHARACTER
	POP	DI
	RET
;--------------------------------------------------------
; SCROLL_DOWN						:
;	THIS ROUTINE MOVES THE CHARACTERS WITHIN A	:
;	DEFINED BLOCK DOWN ON THE SCREEN, FILLING THE	:
;	TOP LINES WITH A DEFINED CHARACTER		:
; INPUT 						:
;	(AH) = CURRENT CRT MODE 			:
;	(AL) = NUMBER OF LINES TO SCROLL		:
;	(CX) = UPPER LEFT CORNER OF REGION		:
;	(DX) = LOWER RIGHT CORNER OF REGION		:
;	(BH) = FILL CHARACTER				:
;	(DS) = DATA SEGMENT				:
;	(ES) = REGEN SEGMENT				:
; OUTPUT						:
;	NONE -- SCREEN IS SCROLLED			:
;--------------------------------------------------------
SCROLL_DOWN:
	STD				; DIRECTION FOR SCROLL
	MOV	BL,AL			; LINE COUNT TO BL
	CMP	AH,4			; TEST FOR GRAPHICS
	JC	N12
	CMP	AH,7			; TEST FOR BW CARD
	JE	N12
	JMP	GRAPHICS_DOWN
N12:					; CONTINUE DOWN
	PUSH	BX			; SAVE ATTRIBUTE IN BH
	MOV	AX,DX			; LOWER RIGHT CORNER
	CALL	SCROLL_POSITION 	; GET REGEN LOCATION
	JZ	N16
	SUB	SI,AX			; SI IS FROM ADDRESS
	MOV	AH,DH			; GET TOTAL # ROWS
	SUB	AH,BL			; COUNT TO MOVE IN SCROLL
N13:
	CALL	N10			; MOVE ONE ROW
	SUB	SI,BP
	SUB	DI,BP
	DEC	AH
	JNZ	N13
N14:
	POP	AX			; RECOVER ATTRIBUTE IN AH
	MOV	AL,' '
N15:
	CALL	N11			; CLEAR ONE ROW
	SUB	DI,BP			; GO TO NEXT ROW
	DEC	BL
	JNZ	N15
	JMP	N5			; SCROLL_END
N16:
	MOV	BL,DH
	JMP	SHORT N14
;--------------------------------------------------------
; READ_AC_CURRENT					:
;	THIS ROUTINE READS THE ATTRIBUTE AND CHARACTER	:
;	AT THE CURRENT CURSOR POSITION AND RETURNS THEM :
;	TO THE CALLER					:
; INPUT 						:
;	(AH) = CURRENT CRT MODE 			:
;	(BH) = DISPLAY PAGE ( ALPHA MODES ONLY )	:
;	(DS) = DATA SEGMENT				:
;	(ES) = REGEN SEGMENT				:
; OUTPUT						:
;	(AL) = CHAR READ				:
;	(AH) = ATTRIBUTE READ				:
;--------------------------------------------------------
READ_AC_CURRENT:
	CMP	AH,4			; IS THIS GRAPHICS
	JC	P1
	CMP	AH,7			; IS THIS BW CARD
	JE	P1
	JMP	GRAPHICS_READ
P1:					; READ_AC_CONTINUE
	CALL	FIND_POSITION
	MOV	SI,BX			; ESTABLISH ADDRESSING IN SI

;----- WAIT FOR HORIZONTAL RETRACE

	MOV	DX,[BiosData.addr6845]	; GET BASE ADDRESS
	ADD	DX,BYTE 6		; POINT AT STATUS PORT
	PUSH	ES			;
	POP	DS			; GET SEGMENT FOR QUICK ACCESS
P2:					; WAIT FOR RETRACE LOW
	IN	AL,DX			; GET STATUS
	TEST	AL,1			; IS HORZ RETRACE LOW
	JNZ	P2			; WAIT UNTIL IT IS
	CLI				; NO MORE INTERRUPTS
P3:					; WAIT FOR RETRACE HIGH
	IN	AL,DX			; GET STATUS
	TEST	AL,1			; IS IT HIGH
	JZ	P3			; WAIT UNTIL IT IS
	LODSW				; GET THE CHAR/ATTR
	JMP	VIDEO_RETURN

FIND_POSITION:
	MOV	CL,BH			; DISPLAY PAGE TO CX
	XOR	CH,CH
	MOV	SI,CX			; MOVE TO SI FOR INDEX
	SAL	SI,1			; * 2 FOR WORD OFFSET
	MOV	AX,[SI+BiosData.cursorPosn]	; GET ROW/COLUMN OF THAT PAGE
	XOR	BX,BX			; SET START ADDRESS TO ZERO
	JCXZ	P5			; NO_PAGE
P4:					; PAGE_LOOP
	ADD	BX,[BiosData.crtLen]	; LENGTH OF BUFFER
	LOOP	P4
P5:					; NO_PAGE
	CALL	POSITION		; DETERMINE LOCATION IN REGEN
	ADD	BX,AX			; ADD TO START OF REGEN
	RET
;------------------------------------------------
; WRITE_AC_CURRENT				:
;	THIS ROUTINE WRITES THE ATTRIBUTE	:
;	AND CHARACTER AT THE CURRENT CURSOR	:
;	POSITION				:
; INPUT 					:
;	(AH) = CURRENT CRT MODE 		:
;	(BH) = DISPLAY PAGE			:
;	(CX) = COUNT OF CHARACTERS TO WRITE	:
;	(AL) = CHAR TO WRITE			:
;	(BL) = ATTRIBUTE OF CHAR TO WRITE	:
;	(DS) = DATA SEGMENT			:
;	(ES) = REGEN SEGMENT			:
; OUTPUT					:
;	NONE					:
;------------------------------------------------
WRITE_AC_CURRENT:
	CMP	AH,4			; IS THIS GRAPHICS
	JC	P6
	CMP	AH,7			; IS THIS BW CARD
	JE	P6
	JMP	GRAPHICS_WRITE
P6:					; WRITE_AC_CONTINUE
	MOV	AH,BL			; GET ATTRIBUTE TO AH
	PUSH	AX			; SAVE ON STACK
	PUSH	CX			; SAVE WRITE COUNT
	CALL	FIND_POSITION
	MOV	DI,BX			; ADDRESS TO DI REGISTER
	POP	CX			; WRITE COUNT
	POP	BX			; CHARACTER IN BX REG
P7:					; WRITE_LOOP

;----- WAIT FOR HORIZONTAL RETRACE

	MOV	DX,[BiosData.addr6845]	; GET BASE ADDRESS
	ADD	DX,BYTE 6		; POINT AT STATUS PORT
P8:
	IN	AL,DX			; GET STATUS
	TEST	AL,1			; IS IT LOW
	JNZ	P8			; WAIT UNTIL IT IS
	CLI				; NO MORE INTERRUPTS
P9:
	IN	AL,DX			; GET STATUS
	TEST	AL,1			; IS IT HIGH
	JZ	P9			; WAIT UNTIL IT IS
	MOV	AX,BX			; RECOVER THE CHAR/ATTR
	STOSW				; PUT THE CHAR/ATTR
	STI				; INTERRUPTS BACK ON
	LOOP	P7			;  AS MANY TIMES AS REQUESTED
	JMP	VIDEO_RETURN
;------------------------------------------------
; WRITE_C_CURRENT				:
;	THIS ROUTINE WRITES THE CHARACTER AT	:
;	THE CURRENT CURSOR POSITION, ATTRIBUTE	:
;	UNCHANGED				:
; INPUT 					:
;	(AH) = CURRENT CRT MODE 		:
;	(BH) = DISPLAY PAGE			:
;	(CX) = COUNT OF CHARACTERS TO WRITE	:
;	(AL) = CHAR TO WRITE			:
;	(DS) = DATA SEGMENT			:
;	(ES) = REGEN SEGMENT			:
;OUTPUT 					:
;	NONE					:
;------------------------------------------------
WRITE_C_CURRENT:
	CMP	AH,4			; IS THIS GRAPHICS
	JC	P10
	CMP	AH,7			; IS THIS BW CARD
	JE	P10
	JMP	GRAPHICS_WRITE
P10:
	PUSH	AX			; SAVE ON STACK
	PUSH	CX			; SAVE WRITE COUNT
	CALL	FIND_POSITION
	MOV	DI,BX			; ADDRESS TO DI
	POP	CX			; WRITE COUNT
	POP	BX			; BL HAS CHAR TO WRITE
P11:					; WRITE_LOOP

;----- WAIT FOR HORIZONTAL RETRACE

	MOV	DX,[BiosData.addr6845]	; GET BASE ADDRESS
	ADD	DX,BYTE 6		; POINT AT STATUS PORT
P12:
	IN	AL,DX			; GET STATUS
	TEST	AL,1			; IS IT LOW
	JNZ	P12			; WAIT UNTIL IT IS
	CLI				; NO MORE INTERRUPTS
P13:
	IN	AL,DX			; GET STATUS
	TEST	AL,1			; IS IT HIGH
	JZ	P13			; WAIT UNTIL IT IS
	MOV	AL,BL			; RECOVER CHAR
	STOSB				; PUT THE CHAR/ATTR
	STI				; INTERRUPTS BACK ON
	INC	DI			; BUMP POINTER PAST ATTRIBUTE
	LOOP	P11			;  AS MANY TIMES AS REQUESTED
	JMP	VIDEO_RETURN
;----------------------------------------------------------------
; READ DOT  -- WRITE DOT					:
;	THESE ROUTINES WILL WRITE A DOT, OR READ THE DOT AT	:
;	THE INDICATED LOCATION					:
; ENTRY --							:
;   DX = ROW (0-199)	(THE ACTUAL VALUE DEPENDS ON THE MODE)	:
;   CX = COLUMN ( 0-639) ( THE VALUES ARE NOT RANGE CHECKED )	:
;   AL = DOT VALUE TO WRITE (1,2 OR 4 BITS DEPENDING ON MODE,	:
;	REQ'D FOR WRITE DOT ONLY, RIGHT JUSTIFIED)              :
;	BIT 7 OF AL=1 INDICATES XOR THE VALUE INTO THE LOCATION :
;   DS = DATA SEGMENT						:
;   ES = REGEN SEGMENT						:
;								:
; EXIT								:
;	AL = DOT VALUE READ, RIGHT JUSTIFIED, READ ONLY 	:
;----------------------------------------------------------------
READ_DOT:
	CALL	R3			; DETERMINE BYTE POSITION OF DOT
	ES MOV	AL,[SI]			; GET THE BYTE
	AND	AL,AH			; MASK OFF THE OTHER BITS IN THE BYTE
	SHL	AL,CL			; LEFT JUSTIFY THE VALUE
	MOV	CL,DH			; GET NUMBER OF BITS IN RESULT
	ROL	AL,CL			; RIGHT JUSTIFY THE RESULT
	JMP	VIDEO_RETURN		; RETURN FROM VIDEO IO

WRITE_DOT:
	PUSH	AX			; SAVE DOT VALUE
	PUSH	AX			;  TWICE
	CALL	R3			; DETERMINE BYTE POSITION OF THE DOT
	SHR	AL,CL			; SHIFT TO SET UP THE BITS FOR OUTPUT
	AND	AL,AH			; STRIP OFF THE OTHER BITS
	ES MOV	CL,[SI]			; GET THE CURRENT BYTE
	POP	BX			; RECOVER XOR FLAG
	TEST	BL,80H			; IS IT ON
	JNZ	R2			; YES, XOR THE DOT
	NOT	AH			; SET THE MASK TO REMOVE THE
	AND	CL,AH			;  INDICATED BITS
	OR	AL,CL			; OR IN THE NEW VALUE OF THOSE BITS
R1:					; FINISH_DOT
	ES MOV	[SI],AL			; RESTORE THE BYTE IN MEMORY
	POP	AX
	JMP	VIDEO_RETURN		; RETURN FROM VIDEO IO
R2:					; XOR_DOT
	XOR	AL,CL			; EXCLUSIVE OR THE DOTS
	JMP	SHORT R1		; FINISH UP THE WRITING
;--------------------------------------------------------
; THIS SUBROUTINE DETERMINES THE REGEN BYTE LOCATION	:
; OF THE INDICATED ROW COLUMN VALUE IN GRAPHICS MODE.	:
; ENTRY --						:
;  DX = ROW VALUE (0-199)				:
;  CX = COLUMN VALUE (0-639)				:
; EXIT --						:
;  SI = OFFSET INTO REGEN BUFFER FOR BYTE OF INTEREST	:
;  AH = MASK TO STRIP OFF THE BITS OF INTEREST		:
;  CL = BITS TO SHIFT TO RIGHT JUSTIFY THE MASK IN AH	:
;  DH = # BITS IN RESULT				:
;--------------------------------------------------------
R3:
	PUSH	BX			; SAVE BX DURING OPERATION
	PUSH	AX			; WILL SAVE AL DURING OPERATION

;----- DETERMINE 1ST BYTE IN IDICATED ROW BY MULTIPLYING ROW VALUE BY 40
;----- ( LOW BIT OF ROW DETERMINES EVEN/ODD, 80 BYTES/ROW

	MOV	AL,40
	PUSH	DX			; SAVE ROW VALUE
	AND	DL,0FEH 		; STRIP OFF ODD/EVEN BIT
	MUL	DL			; AX HAS ADDRESS OF 1ST BYTE
					;  OF INDICATED ROW
	POP	DX			; RECOVER IT
	TEST	DL,1			; TEST FOR EVEN/ODD
	JZ	R4			; JUMP IF EVEN ROW
	ADD	AX,2000H		; OFFSET TO LOCATION OF ODD ROWS
R4:					; EVEN_ROW
	MOV	SI,AX			; MOVE POINTER TO SI
	POP	AX			; RECOVER AL VALUE
	MOV	DX,CX			; COLUMN VALUE TO DX

;----- DETERMINE GRAPHICS MODE CURRENTLY IN EFFECT

;----------------------------------------------------------------
; SET UP THE REGISTERS ACCORDING TO THE MODE			:
;  CH = MASK FOR LOW OF COLUMN ADDRESS (7/3 FOR HIGH/MED RES)	:
;  CL = # OF ADDRESS BITS IN COLUMN VALUE (3/2 FOR H/M) 	:
;  BL = MASK TO SELECT BITS FROM POINTED BYTE (80H/C0H FOR H/M) :
;  BH = NUMBER OF VALID BITS IN POINTED BYTE (1/2 FOR H/M)	:
;----------------------------------------------------------------

	MOV	BX,2C0H
	MOV	CX,302H 		; SET PARMS FOR MED RES
	CMP	[BiosData.crtMode],BYTE 6
	JC	R5			; HANDLE IF MED RES
	MOV	BX,180H
	MOV	CX,703H 		; SET PARMS FOR HIGH RES

;----- DETERMINE BIT OFFSET IN BYTE FROM COLUMN MASK

R5:
	AND	CH,DL			; ADDRESS OF PEL WITHIN BYTE TO CH

;----- DETERMINE BYTE OFFSET FOR THIS LOCATION IN COLUMN

	SHR	DX,CL			; SHIFT BY CORRECT AMOUNT
	ADD	SI,DX			; INCREMENT THE POINTER
	MOV	DH,BH			; GET THE # OF BITS IN RESULT TO DH

;----- MULTIPLY BH (VALID BITS IN BYTE) BY CH (BIT OFFSET)

	SUB	CL,CL			; ZERO INTO STORAGE LOCATION
R6:
	ROR	AL,1			; LEFT JUSTIFY THE VALUE
					;  IN AL (FOR WRITE)
	ADD	CL,CH			; ADD IN THE BIT OFFSET VALUE
	DEC	BH			; LOOP CONTROL
	JNZ	R6			; ON EXIT, CL HAS SHIFT COUNT
					;  TO RESTORE BITS
	MOV	AH,BL			; GET MASK TO AH
	SHR	AH,CL			; MOVE THE MASK TO CORRECT LOCATION
	POP	BX			; RECOVER REG
	RET				; RETURN WITH EVERYTHING SET UP
;----------------------------------------------------------------
; SCROLL UP							:
;	THIS ROUTINE SCROLLS UP THE INFORMATION ON THE CRT	:
; ENTRY 							:
;	CH,CL = UPPER LEFT CORNER OF REGION TO SCROLL		:
;	DH,DL = LOWER RIGHT CORNER OF REGION TO SCROLL		:
;	 BOTH OF THE ABOVE ARE IN CHARACTER POSITIONS		:
;	BH = FILL VALUE FOR BLANKED LINES			:
;	AL = # LINES TO SCROLL (AL=0 MEANS BLANK THE ENTIRE	:
;	     FIELD)						:
;	DS = DATA SEGMENT					:
;	ES = REGEN SEGMENT					:
; EXIT								:
;	NOTHING, THE SCREEN IS SCROLLED 			:
;----------------------------------------------------------------
GRAPHICS_UP:
	MOV	BL,AL			; SAVE LINE COUNT IN BL
	MOV	AX,CX			; GET UPPER LEFT POSITION INTO AX REG

;----- USE CHARACTER SUBROUTINE FOR POSITIONING
;----- ADDRESS RETURNED IS MULTIPLIED BY 2 FROM CORRECT VALUE

	CALL	GRAPH_POSN
	MOV	DI,AX			; SAVE RESULT AS DESTINATION ADDRESS

;----- DETERMINE SIZE OF WINDOW

	SUB	DX,CX
	ADD	DX,101H 		; ADJUST VALUES
	SAL	DH,1			; MULTIPLY # ROWS BY 4
					;  SINCE 8 VERT DOTS/CHAR
	SAL	DH,1			;  AND EVEN/ODD ROWS

;----- DETERMINE CRT MODE

	CMP	[BiosData.crtMode],BYTE 6	; TEST FOR MEDIUM RES
	JNC	R7			; FIND_SOURCE

;----- MEDIUM RES UP

	SAL	DL,1			; # COLUMNS * 2, SINCE 2 BYTES/CHAR
	SAL	DI,1			; OFFSET *2 SINCE 2 BYTES/CHAR

;----- DETERMINE THE SOURCE ADDRESS IN THE BUFFER

R7:					; FIND_SOURCE
	PUSH	ES			; GET SEGMENTS BOTH POINTING TO REGEN
	POP	DS
	SUB	CH,CH			; ZERO TO HIGH OF COUNT REG
	SAL	BL,1			; MULTIPLY NUMBER OF LINES BY 4
	SAL	BL,1
	JZ	R11I			; IF ZERO, THEN BLANK ENTIRE FIELD
	MOV	AL,BL			; GET NUMBER OF LINES IN AL
	MOV	AH,80			; 80 BYTES
	MUL	AH			; DETERMINE OFFSET TO SOURCE
	MOV	SI,DI			; SET UP SOURCE
	ADD	SI,AX			;  ADD IN OFFSET TO IT
	MOV	AH,DH			; NUMBER OF ROWS IN FIELD
	SUB	AH,BL			; DETERMINE NUMBER TO MOVE

;----- LOOP THROUGH, MOVING ONE ROW AT A TIME, BOTH EVEN AND ODD FIELDS

R8I:					; ROW_LOOP
	CALL	R17			; MOVE ONE ROW
	SUB	SI,2000H-80		; MOVE TO NEXT ROW
	SUB	DI,2000H-80
	DEC	AH			; NUMBER OF ROWS TO MOVE
	JNZ	R8I			; CONTINUE TILL ALL MOVED

;----- FILL IN THE VACATED LINE(S)

R9I:					; CLEAR_ENTRY
	MOV	AL,BH			; ATTRIBUTE TO FILL WITH
R10I:
	CALL	R18			; CLEAR THAT ROW
	SUB	DI,2000H-80		; POINT TO NEXT LINE
	DEC	BL			; NUMBER OF LINES TO FILL
	JNZ	R10I			; CLEAR_LOOP
	JMP	VIDEO_RETURN		; EVERYTHING DONE
R11I:					; BLANK_FIELD
	MOV	BL,DH			; SET BLANK COUNT TO
					;  EVERYTHING IN FIELD
	JMP	SHORT R9I		; CLEAR THE FIELD
;----------------------------------------------------------------
; SCROLL DOWN							:
;	THIS ROUTINE SCROLLS DOWN THE INFORMATION ON THE CRT	:
; ENTRY 							:
;	CH,CL = UPPER LEFT CORNER OF REGION TO SCROLL		:
;	DH,DL = LOWER RIGHT CORNER OF REGION TO SCROLL		:
;	 BOTH OF THE ABOVE ARE IN CHARACTER POSITIONS		:
;	BH = FILL VALUE FOR BLANKED LINES			:
;	AL = # LINES TO SCROLL (AL=0 MEANS BLANK THE ENTIRE	:
;	     FIELD)						:
;	DS = DATA SEGMENT					:
;	ES = REGEN SEGMENT					:
; EXIT								:
;	NOTHING, THE SCREEN IS SCROLLED 			:
;----------------------------------------------------------------
GRAPHICS_DOWN:
	STD				; SET DIRECTION
	MOV	BL,AL			; SAVE LINE COUNT IN BL
	MOV	AX,DX			; GET LOWER RIGHT POSITION INTO AX REG

;----- USE CHARACTER SUBROUTINE FOR POSITIONING
;----- ADDRESS RETURNED IS MULTIPLIED BY 2 FROM CORRECT VALUE

	CALL	GRAPH_POSN
	MOV	DI,AX			; SAVE RESULT AS DESTINATION ADDRESS

;----- DETERMINE SIZE OF WINDOW

	SUB	DX,CX
	ADD	DX,101H 		; ADJUST VALUES
	SAL	DH,1			; MULTIPLY # ROWS BY 4
					;  SINCE 8 VERT DOTS/CHAR
	SAL	DH,1			;  AND EVEN/ODD ROWS

;----- DETERMINE CRT MODE

	CMP	[BiosData.crtMode],BYTE 6	; TEST FOR MEDIUM RES
	JNC	R12I			; FIND_SOURCE_DOWN

;----- MEDIUM RES DOWN

	SAL	DL,1			; # COLUMNS * 2, SINCE
					;  2 BYTES/CHAR (OFFSET OK)
	SAL	DI,1			; OFFSET *2 SINCE 2 BYTES/CHAR
	INC	DI			; POINT TO LAST BYTE

;----- DETERMINE THE SOURCE ADDRESS IN THE BUFFER

R12I:					; FIND_SOURCE_DOWN
	PUSH	ES			; BOTH SEGMENTS TO REGEN
	POP	DS
	SUB	CH,CH			; ZERO TO HIGH OF COUNT REG
	ADD	DI,240			; POINT TO LAST ROW OF PIXELS
	SAL	BL,1			; MULTIPLY NUMBER OF LINES BY 4
	SAL	BL,1
	JZ	R16			; IF ZERO, THEN BLANK ENTIRE FIELD
	MOV	AL,BL			; GET NUMBER OF LINES IN AL
	MOV	AH,80			; 80 BYTES/ROW
	MUL	AH			; DETERMINE OFFSET TO SOURCE
	MOV	SI,DI			; SET UP SOURCE
	SUB	SI,AX			;  SUBTRACT THE OFFSET
	MOV	AH,DH			; NUMBER OF ROWS IN FIELD
	SUB	AH,BL			; DETERMINE NUMBER TO MOVE

;----- LOOP THROUGH, MOVING ONE ROW AT A TIME, BOTH EVEN AND ODD FIELDS

R13I:					; ROW_LOOP_DOWN
	CALL	R17			; MOVE ONE ROW
	SUB	SI,2000H+80		; MOVE TO NEXT ROW
	SUB	DI,2000H+80
	DEC	AH			; NUMBER OF ROWS TO MOVE
	JNZ	R13I			; CONTINUE TILL ALL MOVED

;----- FILL IN THE VACATED LINE(S)

R14I:					; CLEAR_ENTRY_DOWN
	MOV	AL,BH			; ATTRIBUTE TO FILL WITH
R15I:					; CLEAR_LOOP_DOWN
	CALL	R18			; CLEAR A ROW
	SUB	DI,2000H+80		; POINT TO NEXT LINE
	DEC	BL			; NUMBER OF LINES TO FILL
	JNZ	R15I			; CLEAR_LOOP_DOWN
	CLD				; RESET THE DIRECTION FLAG
	JMP	VIDEO_RETURN		; EVERYTHING DONE
R16:					; BLANK_FIELD_DOWN
	MOV	BL,DH			; SET BLANK COST TO
					;  EVERYTHING IN FIELD
	JMP	SHORT R14I		; CLEAR THE FIELD

;----- ROUTINE TO MOVE ONE ROW OF INFORMATION

R17:
	MOV	CL,DL			; NUMBER OF BYTES IN THE ROW
	PUSH	SI
	PUSH	DI			; SAVE POINTERS
	REP	MOVSB			; MOVE THE EVEN FIELD
	POP	DI
	POP	SI
	ADD	SI,2000H
	ADD	DI,2000H		; POINT TO THE ODD FIELD
	PUSH	SI
	PUSH	DI			; SAVE THE POINTERS
	MOV	CL,DL			; COUNT BACK
	REP	MOVSB			; MOVE THE ODD FIELD
	POP	DI
	POP	SI			; POINTERS BACK
	RET				; RETURN TO CALLER

;----- CLEAR A SINGLE ROW

R18:
	MOV	CL,DL			; NUMBER OF BYTES IN FIELD
	PUSH	DI			; SAVE POINTER
	REP	STOSB			; STORE THE NEW VALUE
	POP	DI			; POINTER BACK
	ADD	DI,2000H		; POINT TO ODD FIELD
	PUSH	DI
	MOV	CL,DL
	REP	STOSB			; FILL THE ODD FIELD
	POP	DI
	RET				; RETURN TO CALLER
;----------------------------------------------------------------
; GRAPHICS WRITE						:
;	THIS ROUTINE WRITES THE ASCII CHARACTER TO THE		:
;	CURRENT POSITION ON THE SCREEN. 			:
; ENTRY 							:
;	AL = CHARACTER TO WRITE 				:
;	BL = COLOR ATTRIBUTE TO BE USED FOR FOREGROUND COLOR	:
;	 IF BIT 7 IS SET, THE CHAR IS XOR'D INTO THE REGEN      :
;	 BUFFER (0 IS USED FOR THE BACKGROUND COLOR)		:
;	CX = NUMBER OF CHARS TO WRITE				:
;	DS = DATA SEGMENT					:
;	ES = REGEN SEGMENT					:
; EXIT								:
;	NOTHING IS RETURNED					:
;								:
; GRAPHICS READ 						:
;	THIS ROUTINE READS THE ASCII CHARACTER AT THE CURRENT	:
;	CURSOR POSITION ON THE SCREEN BY MATCHING THE DOTS ON	:
;	THE SCREEN TO THE CHARACTER GENERATOR CODE POINTS	:
; ENTRY 							:
;	NONE  (0 IS ASSUMED AS THE BACKGROUND COLOR		:
; EXIT								:
;	AL = CHARACTER READ AT THAT POSITION (0 RETURNED IF	:
;	     NONE FOUND)					:
;								:
; FOR BOTH ROUTINES, THE IMAGES USED TO FORM CHARS ARE		:
;  CONTAINED IN ROM FOR THE 1ST 128 CHARS.  TO ACCESS CHARS	:
;  IN THE SECOND HALF, THE USER MUST INITIALIZE THE VECTOR AT	:
;  INTERRUPT 1FH (LOCATION 0007CH) TO POINT TO THE USER 	:
;  SUPPLIED TABLE OF GRAPHIC IMAGES (8X8 BOXES).		:
;  FAILURE TO DO SO WILL CAUSE IN STRANGE RESULTS		:
;----------------------------------------------------------------
GRAPHICS_WRITE:
	MOV	AH,0			; ZERO TO HIGH OF CODE POINT
	PUSH	AX			; SAVE CODE POINT VALUE

;----- DETERMINE POSITION IN REGEN BUFFER TO PUT CODE POINTS

	CALL	S26			; FIND LOCATION IN REGEN BUFFER
	MOV	DI,AX			; REGEN POINTER IN DI

;----- DETERMINE REGION TO GET CODE POINTS FROM

	POP	AX			; RECOVER CODE POINT
	CMP	AL,80H			; IS IT IN SECOND HALF
	JAE	S1			; YES

;----- IMAGE IS IN FIRST HALF, CONTAINED IN ROM

	MOV	SI,0FA6EH		; OFFSET CRT_CHAR_GEN-OFFSET OF IMAGES
	PUSH	CS			; SAVE SEGMENT ON STACK
	JMP	SHORT S2		; DETERMINE_MODE

;----- IMAGE IS IN SECOND HALF, IN USER RAM

S1:					; EXTEND_CHAR
	SUB	AL,80H			; ZERO ORIGIN FOR SECOND HALF
	PUSH	DS			; SAVE DATA POINTER
	SUB	SI,SI
	MOV	DS,SI			; ESTABLISH VECTOR ADDRESSING
	LDS	SI,[EXT_PTR]		; GET THE OFFSET OF THE TABLE
	MOV	DX,DS			; GET THE SEGMENT OF THE TABLE
	POP	DS			; RECOVER DATA SEGMENT
	PUSH	DX			; SAVE TABLE SEGMENT ON STACK

;----- DETERMINE GRAPHICS MODE IN OPERATION

S2:					; DETERMINE_MODE
	SAL	AX,1			; MULTIPLY CODE POINT
	SAL	AX,1			;  VALUE BY 8
	SAL	AX,1
	ADD	SI,AX			; SI HAS OFFSET OF DESIRED CODES
	CMP	[BiosData.crtMode],BYTE 6
	POP	DS			; RECOVER TABLE POINTER SEGMENT
	JC	S7			; TEST FOR MEDIUM RESOLUTION MODE

;----- HIGH RESOLUTION MODE

S3:					; HIGH_CHAR
	PUSH	DI			; SAVE REGEN POINTER
	PUSH	SI			; SAVE CODE POINTER
	MOV	DH,4			; NUMBER OF LINES THROUGH LOOP
S4:
	LODSB				; GET BYTE FROM CODE POINTS
	TEST	BL,80H			; SHOULD WE USE THE FUNCTION
	JNZ	S6			;  TO PUT CHAR IN
	STOSB				; STORE IN REGEN BUFFER
	LODSB
S5:
	ES MOV	[DI+2000H-1],AL		; STORE IN SECOND HALF
	ADD	DI,BYTE 79		; MOVE TO NEXT ROW IN REGEN
	DEC	DH			; DONE WITH LOOP
	JNZ	S4
	POP	SI
	POP	DI			; RECOVER REGEN POINTER
	INC	DI			; POINT TO NEXT CHAR POSITION
	LOOP	S3			; MORE CHARS TO WRITE
	JMP	VIDEO_RETURN
S6:
	ES XOR	AL,[DI]			; EXCLUSIVE OR WITH CURRENT
	STOSB				; STORE THE CODE POINT
	LODSB				; AGAIN FOR ODD FIELD
	ES XOR	AL,[DI+2000H-1]
	JMP	SHORT S5		; BACK TO MAINSTREAM

;----- MEDIUM RESOLUTION WRITE

S7:					; MED_RES_WRITE
	MOV	DL,BL			; SAVE HIGH COLOR BIT
	SAL	DI,1			; OFFSET*2 SINCE 2 BYTES/CHAR
	CALL	S19			; EXPAND BL TO FULL WORD OF COLOR
S8:					; MED_CHAR
	PUSH	DI			; SAVE REGEN POINTER
	PUSH	SI			; SAVE THE CODE POINTER
	MOV	DH,4			; NUMBER OF LOOPS
S9:
	LODSB				; GET CODE POINT
	CALL	S21			; DOUBLE UP ALL THE BITS
	AND	AX,BX			; CONVERT THEM TO FOREGROUND
					;  COLOR ( 0 BACK )
	TEST	DL,80H			; IS THIS XOR FUNCTION
	JZ	S10			; NO, STORE IT IN AS IT IS
	ES XOR	AH,[DI]			; DO FUNCTION WITH HALF
	ES XOR	AL,[DI+1]		;  AND WITH OTHER HALF
S10:
	ES MOV	[DI],AH			; STORE FIRST BYTE
	ES MOV	[DI+1],AL		; STORE SECOND BYTE
	LODSB				; GET CODE POINT
	CALL	S21
	AND	AX,BX			; CONVERT TO COLOR
	TEST	DL,80H			; AGAIN, IS THIS XOR FUNCTION
	JZ	S11			; NO, JUST STORE THE VALUES
	ES XOR	AH,[DI+2000H]		; FUNCTION WITH FIRST HALF
	ES XOR	AL,[DI+2001H]		; AND WITH SECOND HALF
S11:
	ES MOV	[DI+2000H],AH
	ES MOV	[DI+2000H+1],AL		; STORE IN SECOND PORTION OF BUFFER
	ADD	DI,BYTE 80		; POINT TO NEXT LOCATION
	DEC	DH
	JNZ	S9			; KEEP GOING
	POP	SI			; RECOVER CODE POINTER
	POP	DI			; RECOVER REGEN POINTER
	INC	DI			; POINT TO NEXT CHAR POSITION
	INC	DI
	LOOP	S8			; MORE TO WRITE
	JMP	VIDEO_RETURN
;------------------------
; GRAPHICS READ 	:
;------------------------
GRAPHICS_READ:
	CALL	S26			; CONVERTED TO OFFSET IN REGEN
	MOV	SI,AX			; SAVE IN SI
	SUB	SP,BYTE 8		; ALLOCATE SPACE TO SAVE THE
					;  READ CODE POINTER
	MOV	BP,SP			; POINTER TO SAVE AREA

;----- DETERMINE GRAPHICS MODES

	CMP	[BiosData.crtMode],BYTE 6
	PUSH	ES
	POP	DS			; POINT TO REGEN SEGMENT
	JC	S13			; MEDIUM RESOLUTION

;----- HIGH RESOLUTION READ

;----- GET VALUES FROM REGEN BUFFER AND CONVERT TO CODE POINT

	MOV	DH,4			; NUMBER OF PASSES
S12:
	MOV	AL,[SI] 		; GET FIRST BYTE
	MOV	[BP],AL 		; SAVE IN STORAGE AREA
	INC	BP			; NEXT LOCATION
	MOV	AL,[SI+2000H]		; GET LOWER REGION BYTE
	MOV	[BP],AL 		; ADJUST AND STORE
	INC	BP
	ADD	SI,BYTE 80		; POINTER INTO REGEN
	DEC	DH			; LOOP CONTROL
	JNZ	S12			; DO IT SOME MORE
	JMP	SHORT S15		; GO MATCH THE SAVED CODE POINTS
	NOP

;----- MEDIUM RESOLUTION READ

S13:					; MED_RES_READ
	SAL	SI,1			; OFFSET*2 SINCE 2 BYTES/CHAR
	MOV	DH,4			; NUMBER OF PASSES
S14:
	CALL	S23			; GET PAIR BYTES FROM REGEN
					;  INTO SINGLE SAVE
	ADD	SI,2000H		; GO TO LOWER REGION
	CALL	S23			; GET THIS PAIR INTO SAVE
	SUB	SI,2000H-80		; ADJUST POINTER BACK INTO UPPER
	DEC	DH
	JNZ	S14			; KEEP GOING UNTIL ALL 8 DONE

;----- SAVE AREA HAS CHARACTER IN IT, MATCH IT

S15:					; FIND_CHAR
	MOV	DI,CRT_CHAR_GEN		; ESTABLISH ADDRESSING
	NOP
	PUSH	CS
	POP	ES			; CODE POINTS IN CS
	SUB	BP,BYTE 8		; ADJUST POINTER TO BEGINNING
					;  OF SAVE AREA
	MOV	SI,BP
	CLD				; ENSURE DIRECTION
	MOV	AL,0			; CURRENT CODE POINT BEING MATCHED
S16:
	PUSH	SS			; ESTABLISH ADDRESSING TO STACK
	POP	DS			; FOR THE STRING COMPARE
	MOV	DX,128			; NUMBER TO TEST AGAINST
S17:
	PUSH	SI			; SAVE SAVE AREA POINTER
	PUSH	DI			; SAVE CODE POINTER
	MOV	CX,8			; NUMBER OF BYTES TO MATCH
	REPE	CMPSB			; COMPARE THE 8 BYTES
	POP	DI			; RECOVER THE POINTERS
	POP	SI
	JZ	S18			; IF ZERO FLAG SET, THEN MATCH OCCURRED
	INC	AL			; NO MATCH, MOVE ON TO NEXT
	ADD	DI,BYTE 8		; NEXT CODE POINT
	DEC	DX			; LOOP CONTROL
	JNZ	S17			; DO ALL OF THEM

;----- CHAR NOT MATCHED, MIGHT BE IN USER SUPPLIED SECOND HALF

	CMP	AL,0			; AL <> 0 IF ONLY 1ST HALF SCANNED
	JE	S18			; IF = 0, THEN ALL HAS BEEN SCANNED
	SUB	AX,AX
	MOV	DS,AX			; ESTABLISH ADDRESSING TO VECTOR
	LES	DI,[EXT_PTR]		; GET POINTER
	MOV	AX,ES			; SEE IF THE POINTER REALLY EXISTS
	OR	AX,DI			; IF ALL 0, THEN DOESN'T EXIST
	JZ	S18			; NO SENSE LOOKING
	MOV	AL,128			; ORIGIN FOR SECOND HALF
	JMP	SHORT S16		; GO BACK AND TRY FOR IT

;----- CHARACTER IS FOUND ( AL=0 IF NOT FOUND )

S18:
	ADD	SP,BYTE 8		; READJUST THE STACK, THROW AWAY SAVE
	JMP	VIDEO_RETURN		; ALL DONE
;--------------------------------------------------------
; EXPAND_MED_COLOR					:
;	THIS ROUTINE EXPANDS THE LOW 2 BITS IN BL TO	:
;	FILL THE ENTIRE BX REGISTER			:
; ENTRY 						:
;	BL = COLOR TO BE USED ( LOW 2 BITS )		:
; EXIT							:
;	BX = COLOR TO BE USED ( 8 REPLICATIONS OF THE	:
;	2 COLOR BITS )					:
;--------------------------------------------------------
S19:
	AND	BL,3			; ISOLATE THE COLOR BITS
	MOV	AL,BL			; COPY TO AL
	PUSH	CX			; SAVE REGISTER
	MOV	CX,3			; NUMBER OF TIMES TO DO THIS
S20:
	SAL	AL,1
	SAL	AL,1			; LEFT SHIFT BY 2
	OR	BL,AL			; ANOTHER COLOR VERSION INTO BL
	LOOP	S20			; FILL ALL OF BL
	MOV	BH,BL			; FILL UPPER PORTION
	POP	CX			; REGISTER BACK
	RET				; ALL DONE
;--------------------------------------------------------
; EXPAND_BYTE						:
;	THIS ROUTINE TAKES THE BYTE IN AL AND DOUBLES	:
;	ALL OF THE BITS, TURNING THE 8 BITS INTO	:
;	16 BITS. THE RESULT IS LEFT IN AX		:
;--------------------------------------------------------
S21:
	PUSH	DX			; SAVE REGISTERS
	PUSH	CX
	PUSH	BX
	SUB	DX,DX			; RESULT REGISTER
	MOV	CX,1			; MASK REGISTER
S22:
	MOV	BX,AX			; BASE INTO TEMP
	AND	BX,CX			; USE MASK TO EXTRACT A BIT
	OR	DX,BX			; PUT INTO RESULT REGISTER
	SHL	AX,1
	SHL	CX,1			; SHIFT BASE AND MASK BY 1
	MOV	BX,AX			; BASE TO TEMP
	AND	BX,CX			; EXTRACT THE SAME BIT
	OR	DX,BX			; PUT INTO RESULT
	SHL	CX,1			; SHIFT ONLY MASK NOW,
					;  MOVING TO NEXT BASE
	JNC	S22			; USE MASK BIT COMING OUT TO TERMINATE
	MOV	AX,DX			; RESULT TO PARM REGISTER
	POP	BX
	POP	CX			; RECOVER REGISTERS
	POP	DX
	RET				; ALL DONE
;--------------------------------------------------------
; MED_READ_BYTE 					:
;	THIS ROUTINE WILL TAKE 2 BYTES FROM THE REGEN	:
;	BUFFER, COMPARE AGAINST THE CURRENT FOREGROUND	:
;	COLOR, AND PLACE THE CORRESPONDING ON/OFF BIT	:
;	PATTERN INTO THE CURRENT POSITION IN THE SAVE	:
;	AREA						:
; ENTRY 						:
;	SI,DS = POINTER TO REGEN AREA OF INTEREST	:
;	BX = EXPANDED FOREGROUND COLOR			:
;	BP = POINTER TO SAVE AREA			:
; EXIT							:
;	BP IS INCREMENT AFTER SAVE			:
;--------------------------------------------------------
S23:
	MOV	AH,[SI] 		; GET FIRST BYTE
	MOV	AL,[SI+1]		; GET SECOND BYTE
	MOV	CX,0C000H		; 2 BIT MASK TO TEST THE ENTRIES
	MOV	DL,0			; RESULT REGISTER
S24:
	TEST	AX,CX			; IS THIS SECTION BACKGROUND?
	CLC				; CLEAR CARRY IN HOPES THAT IT IS
	JZ	S25			; IF ZERO, IT IS BACKGROUND
	STC				; WASN'T, SO SET CARRY
S25:	RCL	DL,1			; MOVE THAT BIT INTO THE RESULT
	SHR	CX,1
	SHR	CX,1			; MOVE THE MASK TO THE RIGHT BY 2 BITS
	JNC	S24			; DO IT AGAIN IF MASK DIDN'T FALL OUT
	MOV	[BP],DL 		; STORE RESULT IN SAVE AREA
	INC	BP			; ADJUST POINTER
	RET				; ALL DONE
;------------------------------------------------
; V4_POSITION					:
;	THIS ROUTINE TAKES THE CURSOR POSITION	:
;	CONTAINED IN THE MEMORY LOCATION, AND	:
;	CONVERTS IT INTO AN OFFSET INTO THE	:
;	REGEN BUFFER, ASSUMING ONE BYTE/CHAR.	:
;	FOR MEDIUM RESOLUTION GRAPHICS, 	:
;	THE NUMBER MUST BE DOUBLED.		:
; ENTRY 					:
;	NO REGISTERS, MEMORY LOCATION		:
;	CURSOR_POSN IS USED			:
; EXIT						:
;	AX CONTAINS OFFSET INTO REGEN BUFFER	:
;------------------------------------------------
S26:
	MOV	AX,[BiosData.cursorPosn]; GET CURRENT CURSOR
GRAPH_POSN:
	PUSH	BX			; SAVE REGISTER
	MOV	BX,AX			; SAVE A COPY OF CURRENT CURSOR
	MOV	AL,AH			; GET ROWS TO AL
	MUL	BYTE [BiosData.crtCols]	; MULTIPLY BY BYTES/COLUMN
	SHL	AX,1			; MULTIPLY * 4 SINCE 4 ROWS/BYTE
	SHL	AX,1
	SUB	BH,BH			; ISOLATE COLUMN VALUE
	ADD	AX,BX			; DETERMINE OFFSET
	POP	BX			; RECOVER POINTER
	RET				; ALL DONE
;------------------------------------------------------------------------
; WRITE_TTY								:
;	THIS INTERFACE PROVIDES A TELETYPE LIKE INTERFACE TO THE VIDEO	:
;	CARD. THE INPUT CHARACTER IS WRITTEN TO THE CURRENT CURSOR	:
;	POSITION, AND THE CURSOR IS MOVED TO THE NEXT POSITION. IF THE	:
;	CURSOR LEAVES THE LAST COLUMN OF THE FIELD, THE COLUMN IS SET	:
;	TO ZERO, AND THE ROW VALUE IS INCREMENTED. IF THE ROW VALUE	:
;	LEAVES THE FIELD, THE CURSOR IS PLACED ON THE LAST ROW, FIRST	:
;	COLUMN, AND THE ENTIRE SCREEN IS SCROLLED UP ONE LINE. WHEN	:
;	THE SCREEN IS SCROLLED UP, THE ATTRIBUTE FOR FILLING THE NEWLY	:
;	BLANKED LINE IS READ FROM THE CURSOR POSITION ON THE PREVIOUS	:
;	LINE BEFORE THE SCROLL, IN CHARACTER MODE. IN GRAPHICS MODE,	:
;	THE 0 COLOR IS USED.						:
; ENTRY 								:
;	(AH) = CURRENT CRT MODE 					:
;	(AL) = CHARACTER TO BE WRITTEN					:
;	 NOTE THAT BACK SPACE, CAR RET, BELL AND LINE FEED ARE HANDLED	:
;	 AS COMMANDS RATHER THAN AS DISPLAYABLE GRAPHICS		:
;	(BL) = FOREGROUND COLOR FOR CHAR WRITE IF CURRENTLY IN A	:
;	 GRAPHICS MODE							:
; EXIT									:
;	ALL REGISTERS SAVED						:
;------------------------------------------------------------------------
WRITE_TTY:
	PUSH	AX			; SAVE REGISTERS
	PUSH	AX			; SAVE CHAR TO WRITE
	MOV	AH,3
	MOV	BH,[BiosData.activePage]; GET THE CURRENT ACTIVE PAGE
	INT	10H			; READ THE CURRENT CURSOR POSITION
	POP	AX			; RECOVER CHAR

;----- DX NOW HAS THE CURRENT CURSOR POSITION

	CMP	AL,8			; IS IT A BACKSPACE
	JE	U8			; BACK_SPACE
	CMP	AL,0DH			; IS IT CARRIAGE RETURN
	JE	U9			; CAR_RET
	CMP	AL,0AH			; IS IT A LINE FEED
	JE	U10			; LINE_FEED
	CMP	AL,07H			; IS IT A BELL
	JE	U11			; BELL

;----- WRITE THE CHAR TO THE SCREEN


	MOV	AH,10			; WRITE CHAR ONLY
	MOV	CX,1			; ONLY ONE CHAR
	INT	10H			; WRITE THE CHAR

;----- POSITION THE CURSOR FOR NEXT CHAR

	INC	DL
	CMP	DL,[BiosData.crtCols]	; TEST FOR COLUMN OVERFLOW
	JNZ	U7			; SET CURSOR
	MOV	DL,0			; COLUMN FOR CURSOR
	CMP	DH,24
	JNZ	U6			; SET_CURSOR_INC

;----- SCROLL REQUIRED

U1:
	MOV	AH,2
	INT	10H			; SET THE CURSOR

;----- DETERMINE VALUE TO FILL WITH DURING SCROLL

	MOV	AL,[BiosData.crtMode]	; GET THE CURRENT MODE
	CMP	AL,4
	JC	U2			; READ_CURSOR
	CMP	AL,7
	MOV	BH,0			; FILL WITH BACKGROUND
	JNE	U3			; SCROLL_UP
U2:					; READ_CURSOR
	MOV	AH,8
	INT	10H			; READ CHAR/ATTR AT CURRENT CURSOR
	MOV	BH,AH			; STORE IN BH
U3:					; SCROLL-UP
	MOV	AX,601H 		; SCROLL ONE LINE
	SUB	CX,CX			; UPPER LEFT CORNER
	MOV	DH,24			; LOWER RIGHT ROW
	MOV	DL,[BiosData.crtCols]	; LOWER RIGHT COLUMN
	DEC	DL
U4:					; VIDEO-CALL-RETURN
	INT	10H			; SCROLL UP THE SCREEN
U5:					; TTY-RETURN
	POP	AX			; RESTORE THE CHARACTER
	JMP	VIDEO_RETURN		; RETURN TO CALLER
U6:					; SET-CURSOR-INC
	INC	DH			; NEXT ROW
U7:					; SET-CURSOR
	MOV	AH,2
	JMP	SHORT U4		; ESTABLISH THE NEW CURSOR

;----- BACK SPACE FOUND

U8:
	CMP	DL,0			; ALREADY AT END OF LINE
	JE	U7			; SET_CURSOR
	DEC	DL			; NO -- JUST MOVE IT BACK
	JMP	SHORT U7		; SET_CURSOR

;----- CARRIAGE RETURN FOUND

U9:
	MOV	DL,0			; MOVE TO FIRST COLUMN
	JMP	SHORT U7		; SET_CURSOR

;----- LINE FEED FOUND

U10:
	CMP	DH,24			; BOTTOM OF SCREEN
	JNE	U6			; YES, SCROLL THE SCREEN
	JMP	SHORT U1		; NO, JUST SET THE CURSOR

;----- BELL FOUND

U11:
	MOV	BL,2			; SET UP COUNT FOR BEEP
	CALL	BEEP			; SOUND THE POD BELL
	JMP	SHORT U5		; TTY_RETURN
;----------------------------------------------------------------
; LIGHT PEN							:
;	THIS ROUTINE TESTS THE LIGHT PEN SWITCH AND THE LIGHT	:
;	PEN TRIGGER. IF BOTH ARE SET, THE LOCATION OF THE LIGHT :
;	PEN IS DETERMINED.  OTHERWISE, A RETURN WITH NO 	:
;	INFORMATION IS MADE.					:
; ON EXIT							:
;	(AH) = 0 IF NO LIGHT PEN INFORMATION IS AVAILABLE	:
;		BX,CX,DX ARE DESTROYED				:
;	(AH) = 1 IF LIGHT PEN IS AVAILABLE			:
;		(DH,DL) = ROW,COLUMN OF CURRENT LIGHT PEN	:
;			  POSITION				:
;		(CH) = RASTER POSITION				:
;		(BX) = BEST GUESS AT PIXEL HORIZONTAL POSITION	:
;----------------------------------------------------------------
;------ SUBTRACT_TABLE
V1:
	DB	3,3,5,5,3,3,3,4 ;
READ_LPEN:

;----- WAIT FOR LIGHT PEN TO BE DEPRESSED

	MOV	AH,0			; SET NO LIGHT PEN RETURN CODE
	MOV	DX,[BiosData.addr6845]	; GET BASE ADDRESS OF 6845
	ADD	DX,BYTE 6		; POINT TO STATUS REGISTER
	IN	AL,DX			; GET STATUS REGISTER
	TEST	AL,4			; TEST LIGHT PEN SWITCH
	JNZ	V6			; NOT SET, RETURN

;----- NOW TEST FOR LIGHT PEN TRIGGER

	TEST	AL,2			; TEST LIGHT PEN TRIGGER
	JNZ	V7A			; RETURN WITHOUT RESETTING TRIGGER
	JMP	V7

;----- TRIGGER HAS BEEN SET, READ THE VALUE IN

V7A:
	MOV	AH,16			; LIGHT PEN REGISTERS IN 6845

;----- INPUT REGS POINTED TO BY AH, AND CONVERT TO ROW COLUMN IN DX

	MOV	DX,[BiosData.addr6845]	; ADDRESS REGISTER FOR 6845
	MOV	AL,AH			; REGISTER TO READ
	OUT	DX,AL			; SET IT UP
	INC	DX			; DATA REGISTER
	IN	AL,DX			; GET THE VALUE
	MOV	CH,AL			; SAVE IN CX
	DEC	DX			; ADDRESS REGISTER
	INC	AH
	MOV	AL,AH			; SECOND DATA REGISTER
	OUT	DX,AL
	INC	DX			; POINT TO DATA REGISTER
	IN	AL,DX			; GET SECOND DATA VALUE
	MOV	AH,CH			; AX HAS INPUT VALUE

;----- AX HAS THE VALUE READ IN FROM THE 6845

	MOV	BL,[BiosData.crtMode]
	SUB	BH,BH			; MODE VALUE TO BX
	CS MOV	BL,V1[BX]		; DETERMINE AMOUNT TO SUBTRACT
	SUB	AX,BX			; TAKE IT AWAY
	MOV	BX,[BiosData.crtStart]
	SHR	BX,1
	SUB	AX,BX
	JNS	V2			; IF POSITIVE, DETERMINE MODE
	SUB	AX,AX			; <0 PLAYS AS 0

;----- DETERMINE MODE OF OPERATION

V2:					; DETERMINE_MODE
	MOV	CL,3			; SET *8 SHIFT COUNT
	CMP	[BiosData.crtMode],BYTE 4	; DETERMINE IF GRAPHICS OR ALPHA
	JB	V4			; ALPHA_PEN
	CMP	[BiosData.crtMode],BYTE 7
	JE	V4			; ALPHA_PEN

;----- GRAPHICS MODE

	MOV	DL,40			; DIVISOR FOR GRAPHICS
	DIV	DL			; DETERMINE ROW(AL) AND COLUMN(AH)
					;  AL RANGE 0-99, AH RANGE 0-39

;----- DETERMINE GRAPHIC ROW POSITION

	MOV	CH,AL			; SAVE ROW VALUE IN CH
	ADD	CH,CH			; *2 FOR EVEN/ODD FIELD
	MOV	BL,AH			; COLUMN VALUE TO BX
	SUB	BH,BH			; MULTIPLY BY 8 FOR MEDIUM RES
	CMP	[BiosData.crtMode],BYTE 6	; DETERMINE MEDIUM OR HIGH RES
	JNE	V3			; NOT_HIGH_RES
	MOV	CL,4			; SHIFT VALUE FOR HIGH RES
	SAL	AH,1			; COLUMN VALUE TIMES 2 FOR HIGH RES
V3:					; NOT_HIGH_RES
	SHL	BX,CL			; MULTIPLY *16 FOR HIGH RES

;----- DETERMINE ALPHA CHAR POSITION

	MOV	DL,AH			; COLUMN VALUE FOR RETURN
	MOV	DH,AL			; ROW VALUE
	SHR	DH,1			; DIVIDE BY 4
	SHR	DH,1			;  FOR VALUE IN 0-24 RANGE
	JMP	SHORT V5		; LIGHT_PEN_RETURN_SET

;------ ALPHA MODE ON LIGHT PEN

V4:					; ALPHA_PEN
	DIV	BYTE [BiosData.crtCols]	; DETERMINE ROW,COLUMN VALUE
	MOV	DH,AL			; ROWS TO DH
	MOV	DL,AH			; COLS TO DL
	SAL	AL,CL			; MULTIPLY ROWS *8
	MOV	CH,AL			; GET RASTER VALUE TO RETURN REG
	MOV	BL,AH			; COLUMN VALUE
	XOR	BH,BH			; TO BX
	SAL	BX,CL
V5:					; LIGHT_PEN_RETURN_SET
	MOV	AH,1			; INDICATE EVERTHING SET
V6:					; LIGHT_PEN_RETURN
	PUSH	DX			; SAVE RETURN VALUE (IN CASE)
	MOV	DX,[BiosData.addr6845]	; GET BASE ADDRESS
	ADD	DX,BYTE 7		; POINT TO RESET PARM
	OUT	DX,AL			; ADDRESS, NOT DATA, IS IMPORTANT
	POP	DX			; RECOVER VALUE
V7:					; RETURN_NO_RESET
	POP	DI
	POP	SI
	POP	DS			; DISCARD SAVED BX,CX,DX
	POP	DS
	POP	DS

	POP	DS
	POP	ES
	IRET

%endif ; !__VIDEO_INC__