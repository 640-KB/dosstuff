%ifndef __CASSETTE_INC__
%define __CASSETTE_INC__

;--- INT 15 -----------------------------------------------------
; CASSETTE I/O							:
;	(AH) = 0  TURN CASSETTE MOTOR ON			:
;	(AH) = 1  TURN CASSETTE MOTOR OFF			:
;	(AH) = 2  READ 1 OR MORE 256 BYTE BLOCKS FROM CASSETTE	:
;		(ES,BX) = POINTER TO DATA BUFFER		:
;		(CX) = COUNT OF BYTES TO READ			:
; ON EXIT							:
;	(ES,BX) = POINTER TO LAST BYTE READ + 1 		:
;	(DX) = COUNT OF BYTES ACTUALLY READ			:
;	(CY) = 0 IF NO ERROR OCCURRED				:
;	     = 1 IF ERROR OCCURRED				:
;	(AH) = ERROR RETURN IF (CY)= 1				:
;		= 01 IF CRC ERROR WAS DETECTED			:
;		= 02 IF DATA TRANSITIONS ARE LOST		:
;		= 04 IF NO DATA WAS FOUND			:
;	(AH) = 3 WRITE 1 OR MORE 256 BYTE BLOCKS TO CASSETTE	:
;		(ES,BX) = POINTER TO DATA BUFFER		:
;		(CX) = COUNT OF BYTES TO WRITE			:
; ON EXIT							:
;	(EX,BX) = POINTER TO LAST BYTE WRITTEN + 1		:
;	(CX) = 0						:
;	(AH) = ANY OTHER THAN ABOVE VALUES CAUSES (CY)= 1	:
;		AND (AH)= 80 TO BE RETURNED (INVALID COMMAND).	:
;----------------------------------------------------------------
	TIMES	0F859H-($-$$) DB 0FFh
CASSETTE_IO:
	STI				; INTERRUPTS BACK ON
	PUSH	DS			; ESTABLISH ADDRESSING TO DATA
	CALL	DDS
	AND	[BiosData.biosBreak],BYTE 7FH 	; MAKE SURE BREAK FLAG IS OFF
	CALL	W1			; CASSETTE_IO_CONT
	POP	DS
	RETF	2			; INTERRUPT RETURN
W1:
;--------------------------------------------------------
; PURPOSE:						:
;  TO CALL APPROPRIATE ROUTINE DEPENDING ON REG AH	:
;							:
;  AH		ROUTINE 				:
;--------------------------------------------------------
;  0		MOTOR ON				:
;  1		MOTOR OFF				:
;  2		READ CASSETTE BLOCK			:
;  3		WRITE CASSETTE BLOCK			:
;--------------------------------------------------------
	OR	AH,AH			; TURN ON MOTOR?
	JZ	MOTOR_ON		; YES, DO IT
	DEC	AH			; TURN OFF MOTOR?
	JZ	MOTOR_OFF		; YES, DO IT
	DEC	AH			; READ CASSETTE BLOCK?
	JZ	READ_BLOCK		; YES, DO IT
	DEC	AH			; WRITE CASSETTE BLOCK?
	JNZ	W2			;  NOT_DEFINED
	JMP	WRITE_BLOCK		; YES, DO IT
W2:					; COMMAND NOT DEFINED
	MOV	AH,080H 		; ERROR, UNDEFINED OPERATION
	STC				; ERROR FLAG
	RET
MOTOR_ON:
;----------------------------------------
; PURPOSE:				:
;	TO TURN ON CASSETTE MOTOR	:
;----------------------------------------
	IN	AL,PORT_B		; READ CASSETTE OUTPUT
	AND	AL,~08H			; CLEAR BIT TO TURN ON MOTOR
W3:
	OUT	PORT_B,AL		; WRITE IT OUT
	SUB	AH,AH			; CLEAR AH
	RET
MOTOR_OFF:
;----------------------------------------
; PURPOSE:				:
;	TO TURN CASSETTE MOTOR OFF	:
;----------------------------------------
	IN	AL,PORT_B		; READ CASSETTE OUTPUT
	OR	AL,08H			; SET BIT TO TURN OFF
	JMP	SHORT W3		; WRITE IT, CLEAR ERROR, RETURN
READ_BLOCK:
;----------------------------------------------------------------
; PURPOSE:							:
;	TO READ 1 OR MORE 256 BYTE BLOCKS FROM CASSETTE 	:
;								:
; ON ENTRY:							:
;	ES IS SEGMENT FOR MEMORY BUFFER (FOR COMPACT CODE)	:
;	BX POINTS TO START OF MEMORY BUFFER			:
;	CX CONTAINS NUMBER OF BYTES TO READ			:
; ON EXIT:							:
;	BX POINTS 1 BYTE PAST LAST BYTE PUT IN MEM		:
;	CX CONTAINS DECREMENTED BYTE COUNT			:
;	DX CONTAINS NUMBER OF BYTES ACTUALLY READ		:
;								:
;	CARRY FLAG IS CLEAR IF NO ERROR DETECTED		:
;	CARRY FLAG IS SET IF CRC ERROR DETECTED 		:
;----------------------------------------------------------------
	PUSH	BX			; SAVE BX
	PUSH	CX			; SAVE CX
	PUSH	SI			; SAVE SI
	MOV	SI, 7			; SET UP RETRY COUNT FOR LEADER
	CALL	BEGIN_OP		; BEGIN BY STARTING MOTOR
W4:					; SEARCH FOR LEADER
	IN	AL,PORT_C		; GET INTIAL VALUE
	AND	AL,010H 		; MASK OFF EXTRANEOUS BITS
	MOV	[BiosData.lastVal],AL		; SAVE IN LOC LAST_VAL
	MOV	DX,16250		; # OF TRANSITIONS TO LOOK FOR
W5:					; WAIT_FOR_EDGE
	TEST	[BiosData.biosBreak],BYTE 80H	; CHECK FOR BREAK KEY
	JNZ	W6A			; JUMP IF NO BREAK KEY
					; JUMP IF BREAK KEY HIT
W6:
	DEC	DX
	JNZ	W7			; JUMP IF BEGINNING OF LEADER
W6A:
	JMP	W17			; JUMP IF NO LEADER FOUND
W7:
	CALL	READ_HALF_BIT		; IGNORE FIRST EDGE
	JCXZ	W5			; JUMP IF NO EDGE DETECTED
	MOV	DX,0378H		; CHECK FOR HALF BITS
	MOV	CX,200H 		; MUST HAVE AT LEAST THIS MANY ONE SIZE
					; PULSES BEFORE CHECKNG FOR SYNC BIT (0)
	IN	AL, 021H		; INTERRUPT MASK REGISTER
	OR	AL, 1			; DISABLE TIMER INTERRUPTS
	OUT	021H, AL
W8:					; SEARCH-LDR
	TEST	[BiosData.biosBreak],BYTE 80H 	; CHECK FOR BREAK KEY
	JNZ	W17			; JUMP IF BREAK KEY HIT
	PUSH	CX			; SAVE REG CX
	CALL	READ_HALF_BIT		; GET PULSE WIDTH
	OR	CX, CX			; CHECK FOR TRANSITION
	POP	CX			; RESTORE ONE BIT COUNTER
	JZ	W4			; JUMP IF NO TRANSITION
	CMP	DX,BX			; CHECK PULSE WIDTH
	JCXZ	W9			; IF CX=0 THEN WE CAN LOOK
					; FOR SYNC BIT (0)
	JNC	W4			; JUMP IF ZERO BIT (NOT GOOD LEADER)
	LOOP	W8			; DEC CX AND READ ANOTHER HALF ONE BIT
W9:					; FIND-SYNC
	JC	W8			; JUMP IF ONE BIT (STILL LEADER)

;----- A SYNCH BIT HAS BEEN FOUND. READ SYN CHARACTER:

	CALL	READ_HALF_BIT		; SKIP OTHER HALF OF SYNC BIT (0)
	CALL	READ_BYTE		; READ SYN BYTE
	CMP	AL, 16H 		; SYNCHRONIZATION CHARACTER
	JNE	W16			; JUMP IF BAD LEADER FOUND.

;------ GOOD CRC SO READ DATA BLOCK(S)

	POP	SI			; RESTORE REGS
	POP	CX
	POP	BX
;----------------------------------------------------------------
; READ 1 OR MORE 256 BYTE BLOCKS FROM CASSETTE			:
;								:
; ON ENTRY:							:
;	ES IS SEGMENT FOR MEMORY BUFFER (FOR COMPACT CODE)	:
;	BX POINTS TO START OF MEMORY BUFFER			:
;	CX CONTAINS NUMBER OF BYTES TO READ			:
; ON EXIT:							:
;	BX POINTS 1 BYTE PAST LAST BYTE PUT IN MEM		:
;	CX CONTAINS DECREMENTED BYTE COUNT			:
;	DX CONTAINS NUMBER OF BYTES ACTUALLY READ		:
;----------------------------------------------------------------
	PUSH	CX			; SAVE BYTE COUNT
W10:					; COME HERE BEFORE EACH
					; 256 BYTE BLOCK IS READ
	MOV	WORD [BiosData.crcReg],0FFFFH	; INIT CRC REG
	MOV	DX,256			; SET CX TO DATA BLOCK SIZE
W11:					; RD_BLK
	TEST	[BiosData.biosBreak],BYTE 80H 	; CHECK FOR BREAK KEY
	JNZ	W13			; JUMP IF BREAK KEY HIT
	CALL	READ_BYTE		; READ BYTE FROM CASSETTE
	JC	W13			; CY SET INDICATES NO DATA TRANSITIONS
	JCXZ	W12			; IF WE'VE ALREADY REACHED
					; END OF MEMORY BUFFER
					; SKIP REST OF BLOCK
	ES MOV	[BX],AL			; STORE DATA BYTE AT BYTE PTR
	INC	BX			; INC BUFFER PTR
	DEC	CX			; DEC BYTE COUNTER
W12:					; LOOP UNTIL DATA BLOCK HAS BEEN
					;  READ FROM CASSETTE.
	DEC	DX			; DEC BLOCK CNT
	JG	W11			; RD_BLK
	CALL	READ_BYTE		; NOW READ TWO CRC BYTES
	CALL	READ_BYTE
	SUB	AH,AH			; CLEAR AH
	CMP	WORD [BiosData.crcReg],1D0FH	; IS THE CRC CORRECT
	JNE	W14			; IF NOT EQUAL CRC IS BAD
	JCXZ	W15			; IF BYTE COUNT IS ZERO
					; THEN WE HAVE READ ENOUGH
					; SO WE WILL EXIT
	JMP	SHORT W10		; STILL MORE, SO READ ANOTHER BLOCK
W13:					; MISSING_DATA
					; NO DATA TRANSITIONS SO
	MOV	AH,01H			; SET AH=02 TO INDICATE
					; DATA TIMEOUT
W14:					; BAD-CRC
	INC	AH			; EXIT EARLY ON ERROR
					; SET AH=01 TO INDICATE CRC ERROR
W15:					; RD_BLK_EX
	POP	DX			; CALCULATE COUNT OF
	SUB	DX,CX			; DATA BYTES ACTUALLY READ
					; RETURN COUNT IN REG DX
	PUSH	AX			; SAVE AX (RET CODE)
	TEST	AH, 90H 		; CHECK FOR ERRORS
	JNZ	W18			; JUMP IF ERROR DETECTED
	CALL	READ_BYTE		; READ TRAILER
	JMP	SHORT W18		; SKIP TO TURN OFF MOTOR
W16:					; BAD_LEADER
	DEC	SI			; CHECK RETRIES
	JZ	W17			; JUMP IF TOO MANY RETRIES
	JMP	W4			; JUMP IF NOT TOO MANY RETRIES
W17:					; NO VALID DATA FOUND

;----- NO DATA FROM CASSETTE ERROR, I.E. TIMEOUT

	POP	SI			; RESTORE REGS
	POP	CX			; RESTORE REGS
	POP	BX
	SUB	DX,DX			; ZERO NUMBER OF BYTES READ
	MOV	AH,04H			; TIME OUT ERROR (NO LEADER)
	PUSH	AX
W18:					; MOT-OFF
	IN	AL, 021H		; RE_ENABLE INTERRUPTS
	AND	AL, 0FFH-1
	OUT	021H, AL
	CALL	MOTOR_OFF		; TURN OFF MOTOR
	POP	AX			; RESTORE RETURN CODE
	CMP	AH,01H			; SET CARRY IF ERROR (AH>0)
	CMC
	RET				; FINISHED
;----------------------------------------
; PURPOSE:				:
;	TO READ A BYTE FROM CASSETTE	:
; ON EXIT				:
;	REG AL CONTAINS READ DATA BYTE	:
;----------------------------------------
READ_BYTE:
	PUSH	BX			; SAVE REGS BX,CX
	PUSH	CX
	MOV	CL,8H			; SET BIT COUNTER FOR 8 BITS
W19:					; BYTE-ASM
	PUSH	CX			; SAVE CX
;--------------------------------
; READ DATA BIT FROM CASSETTE	:
;--------------------------------
	CALL	READ_HALF_BIT		; READ ONE PULSE
	JCXZ	W21			; IF CX=0 THEN TIMEOUT
					; BECAUSE OF NO DATA TRANSITIONS
	PUSH	BX			; SAVE 1ST HALF BIT'S
					; PULSE WIDTH (IN BX)
	CALL	READ_HALF_BIT		; READ COMPLEMENTARY PULSE
	POP	AX			; COMPUTE DATA BIT
	JCXZ	W21			; IF CX=0 THEN TIMEOUT DUE TO
					; NO DATA TRANSITIONS
	ADD	BX,AX			; PERIOD
	CMP	BX, 06F0H		; CHECK FOR ZERO BIT
	CMC				; CARRY IS SET IF ONE BIT
	LAHF				; SAVE CARRY IN AH
	POP	CX			; RESTORE CX
					; NOTE:
					;  MS BIT OF BYTE IS READ FIRST.
					;  REG CH IS SHIFTED LEFT WITH
					;  CARRY BEING INSERTED INTO LS
					;   BIT OF CH.
					; AFTER ALL 8 BITS HAVE BEEN
					;   READ, THE MS BIT OF THE DATA BYTE
					;   WILL BE IN THE MS BIT OF REG CH
	RCL	CH,1			; ROTATE REG CH LEFT WITH CARRY TO
					;   LS BIT OF REG CH
	SAHF				; RESTORE CARRY FOR CRC ROUTINE
	CALL	CRC_GEN 		; GENERATE CRC FOR BIT
	DEC	CL			; LOOP TILL ALL 8 BITS OF DATA
					; ASSEMBLED IN REG CH
	JNZ	W19			; BYTE_ASM
	MOV	AL,CH			; RETURN DATA BYTE IN REG AL
	CLC
W20:					; RD-BYT-EX
	POP	CX			; RESTORE REGS CX,BX
	POP	BX
	RET				; FINISHED
W21:					; NO-DATA
	POP	CX			; RESTORE CX
	STC				; INDICATE ERROR
	JMP	SHORT W20		; RD_BYT_EX
;------------------------------------------------
; PURPOSE:					:
;	TO COMPUTE TIME TILL NEXT DATA		:
;	TRANSITION (EDGE)			:
; ON ENTRY:					:
;	EDGE_CNT CONTAINS LAST EDGE COUNT	:
; ON EXIT:					:
;	AX CONTAINS OLD LAST EDGE COUNT 	:
;	BX CONTAINS PULSE WIDTH (HALF BIT)	:
;------------------------------------------------
READ_HALF_BIT:
	MOV	CX, 100 		; SET TIME TO WAIT FOR BIT
	MOV	AH,[BiosData.lastVal]		; GET PRESENT INPUT VALUE
W22:					; RD-H-BIT
	IN	AL,PORT_C		; INPUT DATA BIT
	AND	AL,010H 		; MASK OFF EXTRANEOUS BITS
	CMP	AL,AH			; SAME AS BEFORE?
	LOOPE	W22			; LOOP TILL IT CHANGES
	MOV	[BiosData.lastVal],AL	; UPDATE LAST_VAL WITH NEW VALUE
	MOV	AL,0			; READ TIMER'S COUNTER COMMAND
	OUT	TIM_CTL,AL		; LATCH COUNTER
	MOV	BX,[BiosData.edgeCnt]	; BX GETS LAST EDGE COUNT
	IN	AL,TIMER0		; GET LS BYTE
	MOV	AH,AL			; SAVE IN AH
	IN	AL,TIMER0		; GET MS BYTE
	XCHG	AL,AH			; XCHG AL,AH
	SUB	BX,AX			; SET BX EQUAL TO HALF BIT PERIOD
	MOV	[BiosData.edgeCnt],AX		; UPDATE EDGE COUNT;
	RET
;----------------------------------------------------------------
; PURPOSE							:
;	WRITE 1 OR MORE 256 BYTE BLOCKS TO CASSETTE.		:
;	THE DATA IS PADDED TO FILL OUT THE LAST 256 BYTE BLOCK. :
; ON ENTRY:							:
;	BX POINTS TO MEMORY BUFFER ADDRESS			:
;	CX CONTAINS NUMBER OF BYTES TO WRITE			:
; ON EXIT:							:
;	BX POINTS 1 BYTE PAST LAST BYTE WRITTEN TO CASSETTE	:
;	CX IS ZERO						:
;----------------------------------------------------------------
WRITE_BLOCK:
	PUSH	BX
	PUSH	CX
	IN	AL,PORT_B		; DISABLE SPEAKER
	AND	AL,~02H
	OR	AL, 01H 		; ENABLE TIMER
	OUT	PORT_B,AL
	MOV	AL,0B6H 		; SET UP TIMER -- MODE 3 SQUARE WAVE
	OUT	TIM_CTL,AL
	CALL	BEGIN_OP		; START MOTOR AND DELAY
	MOV	AX,1184 		; SET NORMAL BIT SIZE
	CALL	W31			; SET_TIMER
	MOV	CX,0800H		; SET CX FOR LEADER BYTE COUNT
W23:					; WRITE LEADER
	STC				; WRITE ONE BITS
	CALL	WRITE_BIT		;
	LOOP	W23			; LOOP 'TIL LEADER IS WRITTEN
	CLC				; WRITE SYNC BIT (0)
	CALL	WRITE_BIT
	POP	CX			; RESTORE REGS CX,BX
	POP	BX
	MOV	AL, 16H 		; WRITE SYN CHARACTER
	CALL	WRITE_BYTE
;----------------------------------------------------------------
; PURPOSE							:
;	WRITE 1 OR MORE 256 BYTE BLOCKS TO CASSETTE		:
; ON ENTRY:							:
;	BX POINTS TO MEMORY BUFFER ADDRESS			:
;	CX CONTAINS NUMBER OF BYTES TO WRITE			:
; ON EXIT:							:
;	BX POINTS 1 BYTE PAST LAST BYTE WRITTEN TO CASSETTE	:
;	CX IS ZERO						:
;----------------------------------------------------------------
WR_BLOCK:
	MOV	WORD [BiosData.crcReg],0FFFFH	; INIT CRC
	MOV	DX,256			; FOR 256 BYTES
W24:					; WR-BLK
	ES MOV	AL,[BX]			; READ BYTE FROM MEM
	CALL	WRITE_BYTE		; WRITE IT TO CASSETTE
	JCXZ	W25			; UNLESS CX=0, ADVANCE PTRS & DEC COUNT
	INC	BX			; INC BUFFER POINTER
	DEC	CX			; DEC BYTE COUNTER
W25:					; SKIP-ADV
	DEC	DX			; DEC BLOCK CNT
	JG	W24			; LOOP TILL 256 BYTE BLOCK
					;  IS WRITTEN TO TAPE
;----------------------------------------------------------------
; WRITE CRC							:
;	WRITE 1'S COMPLEMENT OF CRC REG TO CASSETTE             :
;	WHICH IS CHECKED FOR CORRECTNESS WHEN THE BLOCK IS READ :
;  REG AX IS MODIFIED						:
;----------------------------------------------------------------
	MOV	AX,[BiosData.crcReg]	; WRITE THE ONE'S COMPLEMENT OF THE
					;  TWO BYTE CRC TO TAPE
	NOT	AX			; FOR 1'S COMPLEMENT
	PUSH	AX			; SAVE IT
	XCHG	AH,AL			; WRITE MS BYTE FIRST
	CALL	WRITE_BYTE		; WRITE IT
	POP	AX			; GET IT BACK
	CALL	WRITE_BYTE		; NOW WRITE LS BYTE
	OR	CX,CX			; IS BYTE COUNT EXHAUSTED?
	JNZ	WR_BLOCK		; JUMP IF NOT DONE YET
	PUSH	CX			; SAVE REG CX
	MOV	CX, 32			; WRITE OUT TRAILER BITS
W26:					; TRAIL-LOOP
	STC
	CALL	WRITE_BIT
	LOOP	W26			; WRITE UNTIL TRAILER WRITTEN
	POP	CX			; RESTORE REG CX
	MOV	AL, 0B0H		; TURN TIMER2 OFF
	OUT	TIM_CTL,AL
	MOV	AX, 1
	CALL	W31			; SET_TIMER
	CALL	MOTOR_OFF		; TURN MOTOR OFF
	SUB	AX,AX			; NO ERRORS REPORTED ON WRITE OP
	RET				; FINISHED
;--------------------------------
; WRITE A BYTE TO CASSETTE.	:
; BYTE TO WRITE IS IN REG AL.	:
;--------------------------------
WRITE_BYTE:
	PUSH	CX			; SAVE REGS CX,AX
	PUSH	AX
	MOV	CH,AL			; AL=BYTE TO WRITE.
					;   (MS BIT WRITTEN FIRST)
	MOV	CL,8			; FOR 8 DATA BITS IN BYTE.
					;   NOTE: TWO EDGES PER BIT
W27:					; DISASSEMBLE THE DATA BIT
	RCL	CH,1			; ROTATE MS BIT INTO CARRY
	PUSHF				; SAVE FLAGS.
					;   NOTE: DATA BIT IS IN CARRY
	CALL	WRITE_BIT		; WRITE DATA BIT
	POPF				; RESTORE CARRY FOR CRC CALC
	CALL	CRC_GEN 		; COMPUTE CRC ON DATA BIT
	DEC	CL			; LOOP TILL ALL 8 BITS DONE
	JNZ	W27			; JUMP IF NOT DONE YET
	POP	AX			; RESTORE REGS AX,CX
	POP	CX
	RET				; WE ARE FINISHED
;--------------------------------------------------------
; PURPOSE:						:
;	TO WRITE A DATA BIT TO CASSETTE 		:
;	CARRY FLAG CONTAINS DATA BIT			:
;	I.E. IF SET   DATA BIT IS A ONE 		:
;	IF CLEAR DATA BIT IS A ZERO			:
;							:
;  NOTE: TWO EDGES ARE WRITTEN PER BIT			:
;	 ONE BIT  HAS 500 USEC BETWEEN EDGES		:
;	     FOR A 1000 USEC PERIOD (1 MILLISEC)	:
;							:
;	 ZERO BIT HAS 250 USEC BETWEEN EDGES		:
;	     FOR A  500 USEC PERIOD (.5 MILLISEC)	:
; CARRY FLAG IS DATA BIT				:
;--------------------------------------------------------
WRITE_BIT:
					; ASSUME IT'S A '1'
	MOV	AX,1184 		; SET AX TO NOMINAL ONE SIZE
	JC	W28			; JUMP IF ONE BIT
	MOV	AX,592			; NO, SET TO NOMINAL ZERO SIZE
W28:					; WRITE-BIT-AX
	PUSH	AX			; WRITE BIT WITH PERIOD EQ TO VALUE AX
W29:
	IN	AL,PORT_C		; INPUT TIMER_0 OUTPUT
	AND	AL,020H
	JZ	W29			; LOOP TILL HIGH
W30:
	IN	AL,PORT_C		; NOW WAIT TILL TIMER'S OUTPUT IS LOW
	AND	AL,020H
	JNZ	W30
					; RELOAD TIMER WITH PERIOD
					; FOR NEXT DATA BIT
	POP	AX			; RESTORE PERIOD COUNT
W31:					; SET TIMER
	OUT	042H, AL		; SET LOW BYTE OF TIMER 2
	MOV	AL, AH
	OUT	042H, AL		; SET HIGH BYTE OF TIMER 2
	RET
;------------------------------------------------
;  UPDATE CRC REGISTER WITH NEXT DATA BIT	:
;  CRC IS USED TO DETECT READ ERRORS		:
;  ASSUMES DATA BIT IS IN CARRY 		:
;						:
;  REG AX IS MODIFIED				:
;  FLAGS ARE MODIFIED				:
;------------------------------------------------
CRC_GEN:
	MOV	AX,[BiosData.crcReg]
					; THE FOLLOWING INSTUCTIONS
					; WILL SET THE OVERFLOW FLAG
					; IF CARRY AND MS BIT OF CRC
					; ARE UNEQUAL
	RCR	AX,1
	RCL	AX,1
	CLC				; CLEAR CARRY
	JNO	W32			; SKIP IF NO OVERFLOW
					; IF DATA BIT XORED WITH
					;  CRC REG BIT 15 IS ONE
	XOR	AX,0810H		; THEN XOR CRC REG WITH 0810H
	STC				; SET CARRY
W32:
	RCL	AX,1			; ROTATE CARRY (DATA BIT)
					; INTO CRC REG
	MOV	[BiosData.crcReg],AX	; UPDATE CRC_REG
	RET				; FINISHED

BEGIN_OP:				; START TAPE AND DELAY
	CALL	MOTOR_ON		;TURN ON MOTOR
	MOV	BL,42H			;DELAY FOR TAPE DRIVE
					;TO GET UP TO SPEED  (1/2 SEC)
W33:
	MOV	CX,700H 		;INNER LOOP= APPROX. 10 MILLISEC
W34:	LOOP	W34
	DEC	BL
	JNZ	W33
	RET


%endif ; !__CASSETTE_INC__