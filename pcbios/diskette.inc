%ifndef __DISKETTE_INC__
%define __DISKETTE_INC__

;-- INT 13 --------------------------------------------------------------
; DISKETTE I/O								:
;	THIS INTERFACE PROVIDES ACCESS TO THE 5 1/4" DISKETTE DRIVES    :
; INPUT 								:
;	(AH)=0	RESET DISKETTE SYSTEM					:
;		HARD RESET TO NEC, PREPARE COMMAND, RECAL REQUIRED	:
;		ON ALL DRIVES						:
;	(AH)=1	READ THE STATUS OF THE SYSTEM INTO (AL) 		:
;		DISKETTE_STATUS FROM LAST OPERATION IS USED		:
;									:
; REGISTERS FOR READ/WRITE/VERIFY/FORMAT				:
;	(DL) - DRIVE NUMBER (0-3 ALLOWED, VALUE CHECKED)		:
;	(DH) - HEAD NUMBER (0-1 ALLOWED, NOT VALUE CHECKED)		:
;	(CH) - TRACK NUMBER (0-39, NOT VALUE CHECKED)			:
;	(CL) - SECTOR NUMBER (1-8, NOT VALUE CHECKED,			:
;				 NOT USED FOR FORMAT)			:
;	(AL) - NUMBER OF SECTORS ( MAX = 8, NOT VALUE CHECKED, NOT USED :
;					FOR FORMAT)			:
;	(ES:BX) - ADDRESS OF BUFFER ( NOT REQUIRED FOR VERIFY)		:
;									:
;	(AH)=2	READ THE DESIRED SECTORS INTO MEMORY			:
;	(AH)=3	WRITE THE DESIRED SECTORS FROM MEMORY			:
;	(AH)=4	VERIFY THE DESIRED SECTORS				:
;	(AH)=5	FORMAT THE DESIRED TRACK				:
;		FOR THE FORMAT OPERATION, THE BUFFER POINTER (ES,BX)	:
;		MUST POINT TO THE COLLECTION OF DESIRED ADDRESS FIELDS	:
;		FOR THE TRACK.	EACH FIELD IS COMPOSED OF 4 BYTES,	:
;		(C,H,R,N), WHERE C = TRACK NUMBER, H=HEAD NUMBER,	:
;		R = SECTOR NUMBER, N= NUMBER OF BYTES PER SECTOR	:
;		(00=128, 01=256, 02=512, 03=1024).  THERE MUST BE ONE	:
;		ENTRY FOR EVERY SECTOR ON THE TRACK.  THIS INFORMATION	:
;		IS USED TO FIND THE REQUESTED SECTOR DURING READ/WRITE	:
;		ACCESS. 						:
;									:
; DATA VARIABLE -- DISK_POINTER 					:
;	DOUBLE WORD POINTER TO THE CURRENT SET OF DISKETTE PARAMETERS	:
; OUTPUT								:
;	AH = STATUS OF OPERATION					:
;		STATUS BITS ARE DEFINED IN THE EQUATES FOR		:
;		DISKETTE_STATUS VARIABLE IN THE DATA SEGMENT OF THIS	:
;		MODULE. 						:
;	CY = 0	SUCCESSFUL OPERATION (AH=0 ON RETURN)			:
;	CY = 1	FAILED OPERATION (AH HAS ERROR REASON)			:
;	FOR READ/WRITE/VERIFY						:
;		DS,BX,DX,CH,CL PRESERVED				:
;		AL = NUMBER OF SECTORS ACTUALLY READ			:
;		***** AL MAY NOT BE CORRECT IF TIME OUT ERROR OCCURS	:
;	NOTE:	IF AN ERROR IS REPORTED BY THE DISKETTE CODE, THE	:
;		APPROPRIATE ACTION IS TO RESET THE DISKETTE, THEN RETRY :
;		THE OPERATION. ON READ ACCESSES, NO MOTOR START DELAY	:
;		IS TAKEN, SO THAT THREE RETRIES ARE REQUIRED ON READS	:
;		TO ENSURE THAT THE PROBLEM IS NOT DUE TO MOTOR		:
;		START-UP.						:
;------------------------------------------------------------------------
	TIMES	0EC59H-($-$$) DB 0FFh
DISKETTE_IO:
	STI				; INTERRUPTS BACK ON
	PUSH	BX			; SAVE ADDRESS
	PUSH	CX
	PUSH	DS			; SAVE SEGMENT REGISTER VALUE
	PUSH	SI			; SAVE ALL REGISTERS DURING OPERATION
	PUSH	DI
	PUSH	BP
	PUSH	DX
	MOV	BP,SP			; SET UP POINTER TO HEAD PARM
	CALL	DDS
	CALL	J1			; CALL THE REST TO ENSURE DS RESTORED
	MOV	BX,4			; GET THE MOTOR WAIT PARAMETER
	CALL	GET_PARM
	MOV	[BiosData.motorCount],AH; SET THE TIMER COST FOR THE MOTOR
	MOV	AH,[BiosData.disketteStatus]	; GET STATUS OF OPERATION
	CMP	AH,1			; SET THE CARRY FLAG TO INDICATE
	CMC				;  SUCCESS OR FAILURE
	POP	DX			; RESTORE ALL REGISTERS
	POP	BP
	POP	DI
	POP	SI
	POP	DS
	POP	CX
	POP	BX			; RECOVER ADDRESS
	RETF	2			; THROW AWAY SAVED FLAGS

J1:
	MOV	DH,AL			; SAVE # SECTORS IN DH
	AND	[BiosData.motorStatus],BYTE 07FH	; INDICATE A READ OPERATION
	OR	AH,AH			; AH=0
	JZ	DISK_RESET
	DEC	AH			; AH=1
	JZ	DISK_STATUS
	MOV	[BiosData.disketteStatus],BYTE 0	; RESET THE STATUS INDICATOR
	CMP	DL,4			; TEST FOR DRIVE IN 0-3 RANGE
	JAE	J3			; ERROR IF ABOVE
	DEC	AH			; AH=2
	JZ	DISK_READ
	DEC	AH			; AH=3
	JNZ	J2			; TEST_DISK_VERF
	JMP	DISK_WRITE
J2:					; TEST_DISK_VERF
	DEC	AH			; AH=4
	JZ	DISK_VERF
	DEC	AH			; AH=5
	JZ	DISK_FORMAT
J3:					; BAD_COMMAND
	MOV	[BiosData.disketteStatus],BYTE BAD_CMD ; ERROR CODE, NO SECTORS TRANSFERRED
	RET				; UNDEFINED OPERATION

;----- RESET THE DISKETTE SYSTEM

DISK_RESET:
	MOV	DX,03F2H		; ADAPTER CONTROL PORT
	CLI				; NO INTERRUPTS
	MOV	AL,[BiosData.motorStatus] 	; WHICH MOTOR IS ON
	MOV	CL,4			; SHIFT COUNT
	SAL	AL,CL			; MOVE MOTOR VALUE TO HIGH NYBBLE
	TEST	AL, 20H 		; SELECT CORRESPONDING DRIVE
	JNZ	J5			; JUMP IF MOTOR ONE IS ON
	TEST	AL, 40H
	JNZ	J4			; JUMP IF MOTOR TWO IS ON
	TEST	AL, 80H
	JZ	J6			; JUMP IF MOTOR ZERO IS ON
	INC	AL
J4:
	INC	AL
J5:
	INC	AL
J6:
	OR	AL,8			; TURN ON INTERRUPT ENABLE
	OUT	DX,AL			; RESET THE ADAPTER
	MOV	[BiosData.seekStatus],BYTE 0	; SET RECAL REQUIRED ON ALL DRIVES
	MOV	[BiosData.disketteStatus],BYTE 0	; SET OK STATUS FOR DISKETTE
	OR	AL,4			; TURN OFF RESET
	OUT	DX,AL			; TURN OFF THE RESET
	STI				; REENABLE THE INTERRUPTS
	CALL	CHK_STAT_2		; DO SENSE INTERRUPT STATUS
					;  FOLLOWING RESET
	MOV	AL,[BiosData.necStatus]	; IGNORE ERROR RETURN AND DO OWN RESET
	CMP	AL,0C0H 		; TEST FOR DRIVE READY TRANSITION
	JZ	J7			; EVERYTHING OK
	OR	[BiosData.disketteStatus],BYTE BAD_NEC ; SET ERROR CODE
	RET

;----- SEND SPECIFY COMMAND TO NEC

J7:					; DRIVE_READY
	MOV	AH,03H			; SPECIFY COMMAND
	CALL	NEC_OUTPUT		; OUTPUT THE COMMAND
	MOV	BX,1			; FIRST BYTE PARM IN BLOCK
	CALL	GET_PARM		;  TO THE NEC CONTROLLER
	MOV	BX,3			; SECOND BYTE PARM IN BLOCK
	CALL	GET_PARM		;  TO THE NEC CONTROLLER
J8:					; RESET_RET
	RET				; RETURN TO CALLER

;----- DISKETTE STATUS ROUTINE

DISK_STATUS:
	MOV	AL,[BiosData.disketteStatus]
	RET

;----- DISKETTE READ

DISK_READ:
	MOV	AL,046H 		; READ COMMAND FOR DMA
J9:					; DISK_READ_CONT
	CALL	DMA_SETUP		; SET UP THE DMA
	MOV	AH,0E6H 		; SET UP RD COMMAND FOR NEC CONTROLLER
	JMP	SHORT RW_OPN		; GO DO THE OPERATION

;----- DISKETTE VERIFY

DISK_VERF:
	MOV	AL,042H 		; VERIFY COMMAND FOR DMA
	JMP	SHORT J9		; DO AS IF DISK READ

;----- DISKETTE FORMAT

DISK_FORMAT:
	OR	[BiosData.motorStatus],BYTE 80H	; INDICATE WRITE OPERATION
	MOV	AL,04AH 		; WILL WRITE TO THE DISKETTE
	CALL	DMA_SETUP		; SET UP THE DMA
	MOV	AH,04DH 		; ESTABLISH THE FORMAT COMMAND
	JMP	SHORT RW_OPN		; DO THE OPERATION
J10:					; CONTINUATION OF RW_OPN FOR FMT
	MOV	BX,7			; GET THE
	CALL	GET_PARM		;  BYTES/SECTOR VALUE TO NEC
	MOV	BX,9			; GET THE
	CALL	GET_PARM		;  SECTORS/TRACK VALUE TO NEC
	MOV	BX,15			; GET THE
	CALL	GET_PARM		;  GAP LENGTH VALUE TO NEC
	MOV	BX,17			; GET THE FILLER BYTE
	JMP	J16			;  TO THE CONTROLLER

;----- DISKETTE WRITE ROUTINE

DISK_WRITE:
	OR	[BiosData.motorStatus],BYTE 80H	; INDICATE WRITE OPERATION
	MOV	AL,04AH 		; DMA WRITE COMMAND
	CALL	DMA_SETUP
	MOV	AH,0C5H 		; NEC COMMAND TO WRITE TO DISKETTE

;----- ALLOW WRITE ROUTINE TO FALL INTO RW_OPN

;----------------------------------------------------------------
; RW_OPN							:
;	THIS ROUTINE PERFORMS THE READ/WRITE/VERIFY OPERATION	:
;----------------------------------------------------------------
RW_OPN:
	JNC	J11			; TEST FOR DMA ERROR
	MOV	[BiosData.disketteStatus],BYTE DMA_BOUNDARY	; SET ERROR
	MOV	AL,0			; NO SECTORS TRANSFERRED
	RET				; RETURN TO MAIN ROUTINE
J11:					; DO_RW_OPN
	PUSH	AX			; SAVE THE COMMAND

;----- TURN ON THE MOTOR AND SELECT THE DRIVE

	PUSH	CX			; SAVE THE T/S PARMS
	MOV	CL,DL			; GET DRIVE NUMBER AS SHIFT COUNT
	MOV	AL,1			; MASK FOR DETERMINING MOTOR BIT
	SAL	AL,CL			; SHIFT THE MASK BIT
	CLI				; NO INTERRUPTS WHILE DETERMINING
					;  MOTOR STATUS
	MOV	[BiosData.motorCount],BYTE 0FFH	; SET LARGE COUNT DURING OPERATION
	TEST	AL,[BiosData.motorStatus] 	; TEST THAT MOTOR FOR OPERATING
	JNZ	J14			; IF RUNNING, SKIP THE WAIT
	AND	[BiosData.motorStatus],BYTE 0F0H	; TURN OFF ALL MOTOR BITS
	OR	[BiosData.motorStatus],AL 	; TURN ON THE CURRENT MOTOR
	STI				; INTERRUPTS BACK ON
	MOV	AL,10H			; MASK BIT
	SAL	AL,CL			; DEVELOP BIT MASK FOR MOTOR ENABLE
	OR	AL,DL			; GET DRIVE SELECT BITS IN
	OR	AL,0CH			; NO RESET, ENABLE DMA/INT
	PUSH	DX			; SAVE REG
	MOV	DX,03F2H		; CONTROL PORT ADDRESS
	OUT	DX,AL
	POP	DX			; RECOVER REGISTERS

;----- WAIT FOR MOTOR IF WRITE OPERATION

	TEST	[BiosData.motorStatus],BYTE 80H	; IS THIS A WRITE
	JZ	J14			; NO, CONTINUE WITHOUT WAIT
	MOV	BX,20			; GET THE MOTOR WAIT
	CALL	GET_PARM		;  PARAMETER
	OR	AH,AH			; TEST FOR NO WAIT
J12:					; TEST_WAIT_TIME
	JZ	J14			; EXIT WITH TIME EXPIRED
	SUB	CX,CX			; SET UP 1/8 SECOND LOOP TIME
J13:
	LOOP	J13			; WAIT FOR THE REQUIRED TIME
	DEC	AH			; DECREMENT TIME VALUE
	JMP	SHORT J12		; ARE WE DONE YET
J14:					; MOTOR_RUNNING
	STI				; INTERRUPTS BACK ON FOR BYPASS WAIT
	POP	CX

;----- DO THE SEEK OPERATION

	CALL	SEEK			; MOVE TO CORRECT TRACK
	POP	AX			; RECOVER COMMAND
	MOV	BH,AH			; SAVE COMMAND IN BH
	MOV	DH,0			; SET NO SECTORS READ IN CASE OF ERROR
	JC	J17			; IF ERROR, THEN EXIT AFTER MOTOR OFF
	MOV	SI,J17			; DUMMY RETURN ON STACK FOR NEC_OUTPUT
	NOP
	PUSH	SI			;  SO THAT IT WILL RETURN TO MOTOR OFF
					;  LOCATION

;----- SEND OUT THE PARAMETERS TO THE CONTROLLER

	CALL	NEC_OUTPUT		; OUTPUT THE OPERATION COMMAND
	MOV	AH,[BP+1]		; GET THE CURRENT HEAD NUMBER
	SAL	AH,1			; MOVE IT TO BIT 2
	SAL	AH,1
	AND	AH,4			; ISOLATE THAT BIT
	OR	AH,DL			; OR IN THE DRIVE NUMBER
	CALL	NEC_OUTPUT

;----- TEST FOR FORMAT COMMAND

	CMP	BH,04DH 		; IS THIS A FORMAT OPERATION
	JNE	J15			; NO, CONTINUE WITH R/W/V
	JMP	J10			; IF SO, HANDLE SPECIAL
J15:
	MOV	AH,CH			; CYLINDER NUMBER
	CALL	NEC_OUTPUT
	MOV	AH,[BP+1]		; HEAD NUMBER FROM STACK
	CALL	NEC_OUTPUT
	MOV	AH,CL			; SECTOR NUMBER
	CALL	NEC_OUTPUT
	MOV	BX,7			; BYTES/SECTOR PARM FROM BLOCK
	CALL	GET_PARM		;  TO THE NEC
	MOV	BX,9			; EOT PARM FROM BLOCK
	CALL	GET_PARM		;  TO THE NEC
	MOV	BX,11			; GAP LENGTH PARM FROM BLOCK
	CALL	GET_PARM		;  TO THE NEC
	MOV	BX,13			; DTL PARM FROM BLOCK
J16:					; RW_OPN FINISH
	CALL	GET_PARM		;  TO THE NEC
	POP	SI			; CAN NOW DISCARD THAT DUMMY
					;  RETURN ADDRESS

;----- LET THE OPERATION HAPPEN

	CALL	WAIT_INT		; WAIT FOR THE INTERRUPT
J17:					; MOTOR_OFF
	JC	J21			; LOOK FOR ERROR
	CALL	RESULTS 		; GET THE NEC STATUS
	JC	J20			; LOOK FOR ERROR

;----- CHECK THE RESULTS RETURNED BY THE CONTROLLER

	CLD				; SET THE CORRECT DIRECTION
	MOV	SI,BiosData.necStatus	; POINT TO STATUS FIELD
	LODSB				; GET ST0
	AND	AL,0C0H 		; TEST FOR NORMAL TERMINATION
	JZ	J22			; OPN_OK
	CMP	AL,040H 		; TEST FOR ABNORMAL TERMINATION
	JNZ	J18			; NOT ABNORMAL, BAD NEC

;----- ABNORMAL TERMINATION, FIND OUT WHY

	LODSB				; GET ST1
	SAL	AL,1			; TEST FOR EOT FOUND
	MOV	AH,RECORD_NOT_FND
	JC	J19			; RW_FAIL
	SAL	AL,1
	SAL	AL,1			; TEST FOR CRC ERROR
	MOV	AH,BAD_CRC
	JC	J19			; RW_FAIL
	SAL	AL,1			; TEST FOR DMA OVERRUN
	MOV	AH,BAD_DMA
	JC	J19			; RW_FAIL
	SAL	AL,1
	SAL	AL,1			; TEST FOR RECORD NOT FOUND
	MOV	AH,RECORD_NOT_FND
	JC	J19			; RW_FAIL
	SAL	AL,1
	MOV	AH,WRITE_PROTECT	; TEST FOR WRITE PROTECT
	JC	J19			; RW_FAIL
	SAL	AL,1			; TEST MISSING ADDRESS MARK
	MOV	AH,BAD_ADDR_MARK
	JC	J19			; RW_FAIL

;----- NEC MUST HAVE FAILED

J18:					; RW-NEC-FAIL
	MOV	AH,BAD_NEC
J19:					; RW-FAIL
	OR	[BiosData.disketteStatus],AH
	CALL	NUM_TRANS		; HOW MANY WERE REALLY TRANSFERRED
J20:					; RW_ERR
	RET				; RETURN TO CALLER
J21:					; RW_ERR_RES
	CALL	RESULTS 		; FLUSH THE RESULTS BUFFER
	RET

;----- OPERATION WAS SUCCESSFUL

J22:					; OPN_OK
	CALL	NUM_TRANS		; HOW MANY GOT MOVED
	XOR	AH,AH			; NO ERRORS
	RET
;------------------------------------------------------------------------
; NEC_OUTPUT								:
;	THIS ROUTINE SENDS A BYTE TO THE NEC CONTROLLER AFTER TESTING	:
;	FOR CORRECT DIRECTION AND CONTROLLER READY THIS ROUTINE WILL	:
;	TIME OUT IF THE BYTE IS NOT ACCEPTED WITHIN A REASONABLE	:
;	AMOUNT OF TIME, SETTING THE DISKETTE STATUS ON COMPLETION	:
; INPUT 								:
;	(AH)	BYTE TO BE OUTPUT					:
; OUTPUT								:
;	CY = 0	SUCCESS 						:
;	CY = 1	FAILURE -- DISKETTE STATUS UPDATED			:
;		IF A FAILURE HAS OCCURRED, THE RETURN IS MADE ONE LEVEL :
;		HIGHER THAN THE CALLER OF NEC_OUTPUT			:
;		THIS REMOVES THE REQUIREMENT OF TESTING AFTER EVERY	:
;		CALL OF NEC_OUTPUT.					:
;	(AL) DESTROYED							:
;------------------------------------------------------------------------
NEC_OUTPUT:
	PUSH	DX			; SAVE REGISTERS
	PUSH	CX
	MOV	DX,03F4H		; STATUS PORT
	XOR	CX,CX			; COUNT FOR TIME OUT
J23:
	IN	AL,DX			; GET STATUS
	TEST	AL,040H 		; TEST DIRECTION BIT
	JZ	J25			; DIRECTION OK
	LOOP	J23
J24:					; TIME_ERROR
	OR	[BiosData.disketteStatus],BYTE TIME_OUT
	POP	CX
	POP	DX			; SET ERROR CODE AND RESTORE REGS
	POP	AX			; DISCARD THE RETURN ADDRESS
	STC				; INDICATE ERROR TO CALLER
	RET
J25:
	XOR	CX,CX			; RESET THE COUNT
J26:
	IN	AL,DX			; GET THE STATUS
	TEST	AL,080H 		; IS IT READY
	JNZ	J27			; YES, GO OUTPUT
	LOOP	J26			; COUNT DOWN AND TRY AGAIN
	JMP	SHORT J24		; ERROR CONDITION
J27:					; OUTPUT
	MOV	AL,AH			; GET BYTE TO OUTPUT
	MOV	DL,0F5H 		; DATA PORT (3F5)
	OUT	DX,AL			; OUTPUT THE BYTE
	POP	CX			; RECOVER REGISTERS
	POP	DX
	RET				; CY = 0 FROM TEST INSTRUCTION
;------------------------------------------------------------------------
; GET_PARM								:
;	THIS ROUTINE FETCHES THE INDEXED POINTER FROM THE DISK_BASE	:
;	BLOCK POINTED AT BY THE DATA VARIABLE DISK_POINTER. A BYTE FROM :
;	THAT TABLE IS THEN MOVED INTO AH, THE INDEX OF THAT BYTE BEING	:
;	THE PARM IN BX							:
; ENTRY --								:
;   BX = INDEX OF BYTE TO BE FETCHED * 2				:
;	 IF THE LOW BIT OF BX IS ON, THE BYTE IS IMMEDIATELY		:
;	 OUTPUT TO THE NEC CONTROLLER					:
; EXIT --								:
;   AH = THAT BYTE FROM BLOCK						:
;------------------------------------------------------------------------
GET_PARM:
	PUSH	DS			; SAVE SEGMENT
	SUB	AX,AX			; ZERO TO AX
	MOV	DS,AX
	LDS	SI,[DISK_POINTER] 	; POINT TO BLOCK
	SHR	BX,1			; DIVIDE BX BY 2, AND SET FLAG
					;  FOR EXIT
	MOV	AH,[SI+BX]		; GET THE WORD
	POP	DS			; RESTORE SEGMENT
	JC	NEC_OUTPUT		; IF FLAG SET, OUTPUT TO CONTROLLER
	RET				; RETURN TO CALLER
;------------------------------------------------------------------------
; SEEK									:
;	THIS ROUTINE WILL MOVE THE HEAD ON THE NAMED DRIVE TO THE	:
;	NAMED TRACK. IF THE DRIVE HAS NOT BEEN ACCESSED SINCE THE	:
;	DRIVE RESET COMMAND WAS ISSUED, THE DRIVE WILL BE RECALIBRATED. :
; INPUT 								:
;	(DL) = DRIVE TO SEEK ON 					:
;	(CH) = TRACK TO SEEK TO 					:
; OUTPUT								:
;	CY = 0 SUCCESS							:
;	CY = 1 FAILURE -- DISKETTE_STATUS SET ACCORDINGLY		:
;	(AX) DESTROYED							:
;------------------------------------------------------------------------
SEEK:
	MOV	AL,1			; ESTABLISH MASK FOR RECAL TEST
	PUSH	CX			; SAVE INPUT VALUES
	MOV	CL,DL			; GET DRIVE VALUE INTO CL
	ROL	AL,CL			; SHIFT IT BY THE DRIVE VALUE
	POP	CX			; RECOVER TRACK VALUE
	TEST	AL,[BiosData.seekStatus]; TEST FOR RECAL REQUIRED
	JNZ	J28			; NO_RECAL
	OR	[BiosData.seekStatus],AL; TURN ON THE NO RECAL BIT IN FLAG
	MOV	AH,07H			; RECALIBRATE COMMAND
	CALL	NEC_OUTPUT
	MOV	AH,DL
	CALL	NEC_OUTPUT		; OUTPUT THE DRIVE NUMBER
	CALL	CHK_STAT_2		; GET THE INTERUPT AND SENSE INT STATUS
	JC	J32			; SEEK_ERROR

;----- DRIVE IS IN SYNCH WITH CONTROLLER, SEEK TO TRACK

J28:
	MOV	AH,0FH			; SEEK COMMAND TO NEC
	CALL	NEC_OUTPUT
	MOV	AH,DL			; DRIVE NUMBER
	CALL	NEC_OUTPUT
	MOV	AH,CH			; TRACK NUMBER
	CALL	NEC_OUTPUT
	CALL	CHK_STAT_2		; GET ENDING INTERRUPT AND
					;  SENSE STATUS

;----- WAIT FOR HEAD SETTLE

	PUSHF				; SAVE STATE FLAGS
	MOV	BX,18			; GET HEAD SETTLE PARAMETER
	CALL	GET_PARM
	PUSH	CX			; SAVE REGISTER
J29:					; HEAD_SETTLE
	MOV	CX,550			; 1 MS LOOP
	OR	AH,AH			; TEST FOR TIME EXPIRED
	JZ	J31
J30:
	LOOP	J30			; DELAY FOR 1 MS
	DEC	AH			; DECREMENT THE COUNT
	JMP	SHORT J29		; DO IT SOME MORE
J31:
	POP	CX			; RECOVER STATE
	POPF
J32:					; SEEK ERROR
	RET				; RETURN TO CALLER
;------------------------------------------------------------------------
; DMA_SETUP								:
;	THIS ROUTINE SETS UP THE DMA FOR READ/WRITE/VERIFY OPERATIONS.	:
; INPUT 								:
;	(AL) = MODE BYTE FOR THE DMA					:
;	(ES:BX) - ADDRESS TO READ/WRITE THE DATA			:
; OUTPUT								:
;	(AX) DESTROYED							:
;------------------------------------------------------------------------
DMA_SETUP:
	PUSH	CX			; SAVE THE REGISTER
	CLI				; NO MORE INTERRUPTS
	OUT	DMA+12,AL		; SET THE FIRST/LAST F/F
	PUSH	AX
	POP	AX
	OUT	DMA+11,AL		; OUTPUT THE MODE BYTE
	MOV	AX,ES			; GET THE ES VALUE
	MOV	CL,4			; SHIFT COUNT
	ROL	AX,CL			; ROTATE LEFT
	MOV	CH,AL			; GET HIGHEST NYBLE OF ES TO CH
	AND	AL,0F0H 		; ZERO THE LOW NYBBLE FROM SEGMENT
	ADD	AX,BX			; TEST FOR CARRY FROM ADDITION
	JNC	J33
	INC	CH			; CARRY MEANS HIGH 4 BITS MUST BE INC
J33:
	PUSH	AX			; SAVE START ADDRESS
	OUT	DMA+4,AL		; OUTPUT LOW ADDRESS
	MOV	AL,AH
	OUT	DMA+4,AL		; OUTPUT HIGH ADDRESS
	MOV	AL,CH			; GET HIGH 4 BITS
	AND	AL,0FH
	OUT	081H,AL 		; OUTPUT THE HIGH 4 BITS TO
					;  THE PAGE REGISTER

;----- DETERMINE COUNT

	MOV	AH,DH			; NUMBER OF SECTORS
	SUB	AL,AL			;  TIMES 256 INTO AX
	SHR	AX,1			; SECTORS * 128 INTO AX
	PUSH	AX
	MOV	BX,6			; GET THE BYTES/SECTOR PARM
	CALL	GET_PARM
	MOV	CL,AH			; USE AS SHIFT COUNT(0=128,1=256 ETC)
	POP	AX
	SHL	AX,CL			; MULTIPLY BY CORRECT AMOUNT
	DEC	AX			; -1 FOR DMA VALUE
	PUSH	AX			; SAVE COUNT VALUE
	OUT	DMA+5,AL		; LOW BYTE OF COUNT
	MOV	AL,AH
	OUT	DMA+5,AL		; HIGH BYTE OF COUNT
	STI				; INTERRUPTS BACK ON
	POP	CX			; RECOVER COUNT VALUE
	POP	AX			; RECOVER ADDRESS VALUE
	ADD	AX,CX			; ADD, TEST FOR 64K OVERFLOW
	POP	CX			; RECOVER REGISTER
	MOV	AL,2			; MODE FOR 8237
	OUT	DMA+10,AL		; INITIALIZE THE DISKETTE CHANNEL
	RET				; RETURN TO CALLER,
					;  CFL SET BY ABOVE IF ERROR
;------------------------------------------------------------------------
; CHK_STAT_2								:
;	THIS ROUTINE HANDLES THE INTERRUPT RECEIVED AFTER A		:
;	RECALIBRATE, SEEK, OR RESET TO THE ADAPTER.			:
;	THE INTERRUPT IS WAITED FOR, THE INTERRUPT STATUS SENSED,	:
;	AND THE RESULT RETURNED TO THE CALLER.				:
; INPUT 								:
;	NONE								:
; OUTPUT								:
;	CY = 0 SUCCESS							:
;	CY = 1 FAILURE -- ERROR IS IN DISKETTE_STATUS			:
;	(AX) DESTROYED							:
;------------------------------------------------------------------------
CHK_STAT_2:
	CALL	WAIT_INT		; WAIT FOR THE INTERRUPT
	JC	J34			; IF ERROR, RETURN IT
	MOV	AH,08H			; SENSE INTERRUPT STATUS COMMAND
	CALL	NEC_OUTPUT
	CALL	RESULTS 		; READ IN THE RESULTS
	JC	J34			; CHK2_RETURN
	MOV	AL,[BiosData.necStatus]	; GET THE FIRST STATUS BYTE
	AND	AL,060H 		; ISOLATE THE BITS
	CMP	AL,060H 		; TEST FOR CORRECT VALUE
	JZ	J35			; IF ERROR, GO MARK IT
	CLC				; GOOD RETURN
J34:
	RET				; RETURN TO CALLER
J35:					; CHK2_ERROR
	OR	[BiosData.disketteStatus],BYTE BAD_SEEK
	STC				; ERROR RETURN CODE
	RET
;------------------------------------------------------------------------
; WAIT_INT								:
;	THIS ROUTINE WAITS FOR AN INTERRUPT TO OCCUR. A TIME OUT	:
;	ROUTINE TAKES PLACE DURING THE WAIT, SO THAT AN ERROR MAY BE	:
;	RETURNED IF THE DRIVE IS NOT READY.				:
; INPUT 								:
;	NONE								:
; OUTPUT								:
;	CY = 0 SUCCESS							:
;	CY = 1 FAILURE -- DISKETTE_STATUS IS SET ACCORDINGLY		:
;	(AX) DESTROYED							:
;------------------------------------------------------------------------
WAIT_INT:
	STI				; TURN ON INTERRUPTS, JUST IN CASE
	PUSH	BX
	PUSH	CX			; SAVE REGISTERS
	MOV	BL,2			; CLEAR THE COUNTERS
	XOR	CX,CX			; FOR 2 SECOND WAIT
J36:
	TEST	[BiosData.seekStatus],BYTE INT_FLAG	; TEST FOR INTERRUPT OCCURRING
	JNZ	J37
	LOOP	J36			; COUNT DOWN WHILE WAITING
	DEC	BL			; SECOND LEVEL COUNTER
	JNZ	J36
	OR	[BiosData.disketteStatus],BYTE TIME_OUT	; NOTHING HAPPENED
	STC				; ERROR RETURN
J37:
	PUSHF				; SAVE CURRENT CARRY
	AND	[BiosData.seekStatus],BYTE ~INT_FLAG	; TURN OFF INTERRUPT FLAG
	POPF				; RECOVER CARRY
	POP	CX
	POP	BX			; RECOVER REGISTERS
	RET				; GOOD RETURN CODE COMES
					;  FROM TEST INST
;--------------------------------------------------------
; DISK_INT						:
;	THIS ROUTINE HANDLES THE DISKETTE INTERRUPT	:
; INPUT 						:
;	NONE						:
; OUTPUT						:
;	THE INTERRUPT FLAG IS SET IS SEEK_STATUS	:
;--------------------------------------------------------
	TIMES	0EF57H-($-$$) DB 0FFh
DISK_INT:
	STI				; RE ENABLE INTERRUPTS
	PUSH	DS
	PUSH	AX
	CALL	DDS
	OR	[BiosData.seekStatus],BYTE INT_FLAG
	MOV	AL,20H			; END OF INTERRUPT MARKER
	OUT	20H,AL			; INTERRUPT CONTROL PORT
	POP	AX
	POP	DS			; RECOVER SYSTEM
	IRET				; RETURN FROM INTERRUPT
;------------------------------------------------------------------------
; RESULTS								:
;	THIS ROUTINE WILL READ ANYTHING THAT THE NEC CONTROLLER HAS	:
;	TO SAY FOLLOWING AN INTERRUPT.					:
; INPUT 								:
;	NONE								:
; OUTPUT								:
;	CY = 0	SUCCESSFUL TRANSFER					:
;	CY = 1	FAILURE -- TIME OUT IN WAITING FOR STATUS		:
;	NEC_STATUS AREA HAS STATUS BYTE LOADED INTO IT			:
;	(AH) DESTROYED							:
;------------------------------------------------------------------------
RESULTS:
	CLD
	MOV	DI,BiosData.necStatus	; POINTER TO DATA AREA
	PUSH	CX			; SAVE COUNTER
	PUSH	DX
	PUSH	BX
	MOV	BL,7			; MAX STATUS BYTES

;----- WAIT FOR REQUEST FOR MASTER

J38:					; INPUT_LOOP
	XOR	CX,CX			; COUNTER
	MOV	DX,03F4H		; STATUS PORT
J39:					; WAIT FOR MASTER
	IN	AL,DX			; GET STATUS
	TEST	AL,080H 		; MASTER READY
	JNZ	J40A			; TEST_DIR
	LOOP	J39			; WAIT_MASTER
	OR	[BiosData.disketteStatus],BYTE TIME_OUT
J40:					; RESULTS_ERROR
	STC				; SET ERROR RETURN
	POP	BX
	POP	DX
	POP	CX
	RET

;----- TEST THE DIRECTION BIT

J40A:
	IN	AL,DX			; GET STATUS REG AGAIN
	TEST	AL,040H 		; TEST DIRECTION BIT
	JNZ	J42			; OK TO READ STATUS
J41:					; NEC_FAIL
	OR	[BiosData.disketteStatus],BYTE BAD_NEC
	JMP	SHORT J40		; RESULTS ERROR

;----- READ IN THE STATUS

J42:					; INPUT STATUS
	INC	DX			; POINT AT DATA PORT
	IN	AL,DX			; GET THE DATA
	MOV	[DI],AL 		; STORE THE BYTE
	INC	DI			; INCREMENT THE POINTER
	MOV	CX,10			; LOOP TO KILL TIME FOR NEC
J43:	LOOP	J43
	DEC	DX			; POINT AT STATUS PORT
	IN	AL,DX			; GET STATUS
	TEST	AL,010H 		; TEST FOR NEC STILL BUSY
	JZ	J44			; RESULTS DONE
	DEC	BL			; DECREMENT THE STATUS COUNTER
	JNZ	J38			; GO BACK FOR MORE
	JMP	SHORT J41		; CHIP HAS FAILED

;----- RESULT OPERATION IS DONE

J44:
	POP	BX
	POP	DX
	POP	CX			; RECOVER REGISTERS
	RET				; GOOD RETURN CODE FROM TEST INST
;----------------------------------------------------------------
; NUM_TRANS							:
;	THIS ROUTINE CALCULATES THE NUMBER OF SECTORS THAT	:
;	WERE ACTUALLY TRANSFERRED TO/FROM THE DISKETTE		:
; INPUT 							:
;	(CH) = CYLINDER OF OPERATION				:
;	(CL) = START SECTOR OF OPERATION			:
; OUTPUT							:
;	(AL) = NUMBER ACTUALLY TRANSFERRED			:
;	NO OTHER REGISTERS MODIFIED				:
;----------------------------------------------------------------
NUM_TRANS:
	MOV	AL,[BiosData.necStatus+3] 	; GET CYLINDER ENDED UP ON
	CMP	AL,CH			; SAME AS THE STARTED
	MOV	AL,[BiosData.necStatus+5] 	; GET ENDING SECTOR
	JZ	J45			; IF ON SAME CYL, THEN NO ADJUST
	MOV	BX,8
	CALL	GET_PARM		; GET EOT VALUE
	MOV	AL,AH			;  INTO AL
	INC	AL			; USE EOT+1 FOR CALCULATION
J45:
	SUB	AL,CL			; SUBTRACT START FROM END
	RET
;------------------------------------------------------------------------
; DISK_BASE								:
;	THIS IS THE SET OF PARAMETERS REQUIRED FOR DISKETTE OPERATION,	:
;	THEY ARE POINTED AT BY THE DATA VARIABLE DISK_POINTER. TO	:
;	MODIFY THE PARAMETERS, BUILD ANOTHER PARAMETER BLOCK AND POINT	:
;	DISK_POINTER TO IT						:
;------------------------------------------------------------------------
	TIMES	0EFC7H-($-$$) DB 0FFh
DISK_BASE:
	DB	11001111B	; SRT=C, HD UNLOAD=0F - 1ST SPECIFY BYTE
	DB	2		; HD LOAD=1, MODE=DMA - 2ND SPECIFY BYTE
	DB	MOTOR_WAIT	; WAIT AFTER OPN TIL MOTOR OFF
	DB	2		; 512 BYTES/SECTOR
	DB	8		; EOT (LAST SECTOR ON TRACK)
	DB	02AH		; GAP LENGTH
	DB	0FFH		; DTL
	DB	050H		; GAP LENGTH FOR FORMAT
	DB	0F6H		; FILL BYTE FOR FORMAT
	DB	25		; HEAD SETTLE TIME (MILLISECONDS)
	DB	4		; MOTOR START TIME (1/8 SECONDS)

%endif ; !__DISKETTE_INC__